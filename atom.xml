<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BG运维说</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-03T13:57:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Andy Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新年已过，你的新目标确定了吗</title>
    <link href="http://yoursite.com/2018/03/03/%E6%96%B0%E5%B9%B4%E5%B7%B2%E8%BF%87%EF%BC%8C%E4%BD%A0%E7%9A%84%E6%96%B0%E7%9B%AE%E6%A0%87%E7%A1%AE%E5%AE%9A%E4%BA%86%E5%90%97/"/>
    <id>http://yoursite.com/2018/03/03/新年已过，你的新目标确定了吗/</id>
    <published>2018-03-03T13:50:06.000Z</published>
    <updated>2018-03-03T13:57:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2577135-b86470e7821f4c6d..1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<blockquote>
<p>新的一年</p>
</blockquote>
<p>时至今日，大多数为生活奔波的人都已经工作一周多了，而随着昨晚的元宵晚会和鞭炮轰鸣，我才意识到新年是真正的已过。不太清楚大家对于新年持一种怎样的看法，但对于我来说每一个新年都是激动人心却又忧心忡忡的。</p>
<p>为什么激动人心却又忧心忡忡呢？因为新的一年对于我来说不仅仅是年龄的增长，而更多的是年龄增长背后所附带的东西。比如说新的一年随着知识和资金的积累，我可能因为有更多想去尝试的东西而感到激动人心，同时又因为年龄的增长而不得不考虑家庭、个人成长以及个人责任等这些未知且必须面对的事情。虽然新的一年未知且当前忧心忡忡，但未来也并不需要害怕，因为未来正因为这种不确定性和未知性而变得格外吸引我，我相信只要有明确的目标且有规划的去执行，即使有太多的变化，未来应该也不会太差。</p>
<a id="more"></a>
<p>记得18年元旦那天，我自己对17年做了一个大概总结，并对18年工作上的规划做了大概的展望，虽然17年也有对16年进行大概的总结，但随着不断学习和成长过程中才发现之前的总结是多么的粗糙且多么不具体，甚至在过去一年中对那些犯过的错误、做得好坏之间并没有留下进行对比反思的凭据，所以新的一年为了改变这种状态打算先从18年新目标的规划开始进行，希望能够在18年剩下的十来个月不断迭代实现自己的目标。</p>
<p>作为一个特色社会主义社会下的自然人而言，大多数人的活动基本上围绕着<code>工作</code>和<code>生活</code>两个维度展开的，所以我的目标整体也不会偏离这两个维度。</p>
<p>但随着互联网的高速发展，我们大部分人的工作和生活也都是相互融合且交差进行的，比方说我们在微信上正和客户沟通着产品的细节而同时又在叮嘱父母天气异常要注意保暖，间隙间我们又读到一篇<code>人人都是产品经理</code>上一篇关于产品方面的文章，又和客户沟通起来产品的细节，这样在微信上小小的会话切换其实已经在工作和生活两个维度来回切换了一次了，所以从这个小现象来看工作和生活已然成为不可独立对待的两个维度，其实你可能没有注意到，阅读一篇关于产品的文章既可以是个人在生活中知识、思维提高的过程，又可以是满足工作需求学习的过程，正是由于这种具有通用型的活动将生活和工作更加密切的关联在了一起。说了这么多废话，其实是我的懒癌症又犯了，因为不想对生活和工作进行分别设立目标，懂我的人都知道，因为我。。。。太懒！</p>
<p>好啦好啦，认真定几个目标吧，只求18年有事可做，知道做什么。</p>
<blockquote>
<p>18年目标</p>
</blockquote>
<h3 id="1-运动"><a href="#1-运动" class="headerlink" title="1. 运动"></a>1. 运动</h3><p>第一个目标与其说是运动还不如说是<code>跑步</code>，虽然跑步也是一种运动方式，但为什么说是运动呢,因为之前在《进化的大脑》中学习到人在运动的过程中不仅可以增强免疫力，减少病菌感染，最重要的是人在运动的过程中能够不断改善大脑的进化，并且能够调整个人的心情，说的更直白点就是运动可能会使你变得思维更加活跃，变得更加聪明，而且会因为的心情好了而更显年轻(反正我是这么认为的)。运动项目多了去了，但我只擅长跑步，所以第一个目标就是跑步，希望跑步能够让自己更加健康，心情更加舒畅，脑子更加灵活，能够有更多的经历去参与到生活和工作中去。不过健康、舒畅、灵活这些都是泛概念，可能一年过后又会是无法回顾，那么如何量化<code>运动(跑步)</code>这个目标呢？方式当然很多了，比如说定个小目标，每周运动(跑步)的次数以及运动量(跑量)，亦或者定个大目标—体重成功减掉N斤。当然，像我这么懒的人是不会选择后者的，因为这个目标需要经过合理计算然后才能确定减掉N斤肉，因为我懒，所以我只打算去量化每周的运动量，因为持续的运动会持续的改善身体状况、心情以及大脑的思维状况，至于体重下降多少，那就听天由命了(当前68.5)，大致的目标如下，而且我会对每一次运动进行记录打卡。</p>
<table>
<thead>
<tr>
<th>必选</th>
<th>可选</th>
</tr>
</thead>
<tbody>
<tr>
<td>每周运动量3*(半小时核心+5公里)</td>
<td>周末10公里拉链(恶劣天气除外) </td>
</tr>
<tr>
<td>全年至少3次全马跑量</td>
<td>适当的户外徒步/越野马拉松</td>
</tr>
</tbody>
</table>
<p><a href="https://github.com/xxbandy/sport" target="_blank" rel="external">打卡记录</a></p>
<h3 id="2-学习"><a href="#2-学习" class="headerlink" title="2. 学习"></a>2. 学习</h3><p>学习也是非常重要的，特别是在互联网飞速发展的今天，如果不持续学习并且对相关的认知进行持续思考，可能下一个淘汰的就是你。对于学习这个目标来说，我个人认为必须明白三个道理，即学什么，为什么要学，如何去学，虽然可能大家都知道套路，但是往往在学习初期并没有去思考这三点，因此导致很多学习某个知识过程中就放弃或中断了。而对于我来说，2018我会围绕效率、认知、服务、理财四个维度去学习来补充我的工作和生活。</p>
<p>不过在学习方面第一点需要做的就是对于学习目标的<code>总结</code>,比如<code>读书笔记</code>，<code>产品思考</code>，<code>创新日记本</code>等。</p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p>这里的效率更多指的是工作上的效率，毕竟生活是用来体验和享受的，如果过多注重效率的话，可能会丧失一些生活的乐趣，而提高了工作效率，我们就会有更多时间去做工作之外的事情。那么对于提高工作效率，首先需要搞明白的就是工作的主要内容是什么，工作流程是怎样的，工作流程如何优化，然后才是如何提高效率。比如说我自己是搞互金行业业务运维的，那主要工作内容就是从质量、效率、成本、稳定四个大方向进行服务保障的，那对于我当前的工作内容基本就是业务方提需求，然后我们根据业务方的需求进行解决方案的提供并进行实施，这个过程中会发现很多需求是有通用性的，并且很多都是重复实施的，只是针对的业务方不一样。那么针对这种情况，提高效率的方法就是对业务需求进行深度剖析，然后进行高度抽象，将可重复实施的操作进行服务化、自动化，如此进行反复迭代以实现让业务方进行需求自满足的状态，这样就可以将N件事务抽象成1件事务进行操作处理。而在这过程中往往是需要很多知识理论作为支撑的，比如说运维技术知识体系、业务流程梳理、抽象化以及自动化方面的技术。因此对于工作效率的提高方面，大概给自己定如下目标:</p>
<ul>
<li>不断学习运维相关技术，同时对AI、微服务、云等相关技术进行不断学习，在保障业务稳定的同时保持技术敏感度</li>
<li>学习手绘，对业务流程进行形象、抽象化梳理，提高对事物的全局逻辑掌控</li>
<li>学习Golang，对业务流进行自动化实现</li>
<li>学习手账记录法，对工作中的时间区间进行量化，保证某一事件的独立时间区间处理(<code>专注</code>)</li>
<li>进行文档记录和优化处理</li>
<li>练习写字</li>
</ul>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>服务这块就比较通俗了，就是给别人提供服务，提供帮助，而具体的方式就是博客之类的自媒体了，而在服务这块给自己定的目标大概如下：</p>
<ul>
<li>学习并持续运营简书+公众号，分享自己的知识经验，同时希望能帮助到他人</li>
<li>学习产品方面的知识，通过产品化提供更好的服务</li>
</ul>
<p><code>注意:可以分享产品方面的文章和书籍</code></p>
<h4 id="理财"><a href="#理财" class="headerlink" title="理财"></a>理财</h4><p>很显然，当我们手里有相对充裕的资金时，我们必须要学习的就是理财，不论是为了应对未来的通货膨胀还是应对未知的风险，我们都应该将我们的充裕资金进行合理的资产配置以实现资产增加。为此制定如下大概目标:</p>
<ul>
<li>学习基金、证券等基础理财知识</li>
<li>学习个人资产配置</li>
<li>使用一定资金进行基金、证券市场的尝试</li>
</ul>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4><p>2017年提的比较多的一个词中有一个词称作<code>&quot;认知升级&quot;</code>，所谓认知是指人们获得知识或应用知识的过程，或信息加工的过程，这也是人的最基本的心理过程，而<code>认知升级</code>我个人认为也可以理解为对个体思维进行信息处理的心理过程进行的升级。通俗一点也可以理解为认知就是学习知识，并对知识能够很好的运用，而认知升级的过程可以理解为在原有的知识体系之上进行深入思考从而进行另外一种场景探索和使用(我是这么理解的)。</p>
<p>举个很简单的例子，记得在大三做一个关于电子银行相关的大作业过程中，一个舍友提到说”比特币这个东西真不错”，在支付宝刚开始盛行的年代里，大家为了完成作业，并不会对这么一种新的支付概念进行学习和研究，而从去年一年比特币的发展中可以看出，比特币不论是从概念还是底层技术上的实现都是一定价值优势的，估计这也是各界大佬们纷纷在<code>虚拟货币</code>和<code>区块链技术</code>进行大笔投资的主要原因了吧。而18年如果你不知道比特币或者不知道区块链的话，我想可能对于上进的你来说生活会缺少一些精彩与新鲜。</p>
<p>所以说到<code>认知</code>这里，如何去提高自己的认知能力并进行认知升级呢?其实我现在也没太搞明白，但有一点很重要，就是多学习、多思考，多去体验新鲜的事物来开阔自己的眼界。对于认知层面的目标目前暂不明确，但我发现在<code>得到</code>、<code>分答</code>、<code>知识星球</code>等付费栏目中有很多关于认知方面的课程，在哪里你可以学到更多，可以和更多行业前沿的人进行学习、沟通以及交流。</p>
<p>不过在认知这里我将坚持一件事情就是去持续记录，我简单称之为<code>创意日记本</code>主要用来记录自己在日常生活中突发的一些灵感以及认知升级的过程。</p>
<h3 id="3-生活"><a href="#3-生活" class="headerlink" title="3. 生活"></a>3. 生活</h3><p><code>运动</code>和<code>学习</code>两大目标是为了保障和实现个人生活目标的，正所谓生活是需要成本的，那这里的成本不仅有个人的身体和精力成本，同时也需要经济和认识成本，这样才有可能享受并体验到更好的生活。所以希望在成本保障的基础上能够提高自己的生活质量，比如带父母来北京玩、换个更大更舒适，生活更方便的房子、学习做自己最爱吃的菜、去某个国家旅游一次、尝试一次极限运动、改善自己的外在形象等等。</p>
<p>以上就是我整理的今年的大概的目标，说实话，我不确定上述目标会实现多少，有的可以量化，有的比较主观，但我会持续记录18年的重要经历以及成长过程，希望自己能够成长更多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2577135-b86470e7821f4c6d..1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自网络&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;新的一年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时至今日，大多数为生活奔波的人都已经工作一周多了，而随着昨晚的元宵晚会和鞭炮轰鸣，我才意识到新年是真正的已过。不太清楚大家对于新年持一种怎样的看法，但对于我来说每一个新年都是激动人心却又忧心忡忡的。&lt;/p&gt;
&lt;p&gt;为什么激动人心却又忧心忡忡呢？因为新的一年对于我来说不仅仅是年龄的增长，而更多的是年龄增长背后所附带的东西。比如说新的一年随着知识和资金的积累，我可能因为有更多想去尝试的东西而感到激动人心，同时又因为年龄的增长而不得不考虑家庭、个人成长以及个人责任等这些未知且必须面对的事情。虽然新的一年未知且当前忧心忡忡，但未来也并不需要害怕，因为未来正因为这种不确定性和未知性而变得格外吸引我，我相信只要有明确的目标且有规划的去执行，即使有太多的变化，未来应该也不会太差。&lt;/p&gt;
    
    </summary>
    
    
      <category term="目标管理" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/"/>
    
      <category term="创新日记本" scheme="http://yoursite.com/tags/%E5%88%9B%E6%96%B0%E6%97%A5%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="手绘" scheme="http://yoursite.com/tags/%E6%89%8B%E7%BB%98/"/>
    
      <category term="产品思维" scheme="http://yoursite.com/tags/%E4%BA%A7%E5%93%81%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA-DIGITS测试使用</title>
    <link href="http://yoursite.com/2018/01/02/NVIDIA-DIGITS%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/02/NVIDIA-DIGITS测试使用/</id>
    <published>2018-01-02T02:14:32.000Z</published>
    <updated>2018-01-02T02:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DIGITS简介"><a href="#DIGITS简介" class="headerlink" title="DIGITS简介"></a>DIGITS简介</h3><p><a href="https://github.com/NVIDIA/DIGITS" target="_blank" rel="external">DIGITS</a>: Deep Learning GPU Training System1，是由英伟达（NVIDIA）公司开发的第一个交互式深度学习GPU训练系统。目的在于整合现有的Deep Learning开发工具，实现深度神经网络（Deep Neural Network，DNN）设计、训练和可视化等任务变得简单化。DIGITS是基于浏览器的接口，因而通过实时的网络行为的可视化，可以快速设计最优的DNN。DIGITS是开源软件，可在GitHub上找到，因而开发人员可以扩展和自定义DIGITS。</p>
<a id="more"></a>
<p><a href="https://devblogs.nvidia.com/parallelforall/digits-deep-learning-gpu-training-system/" target="_blank" rel="external">英文介绍</a></p>
<h3 id="DIGITS特性"><a href="#DIGITS特性" class="headerlink" title="DIGITS特性"></a>DIGITS特性</h3><ul>
<li>提供了友好的用户界面，只需简单的点击即完成DNNs的训练。DIGITS是一个Web应用，用浏览器访问，上图是典型的工作流程图。</li>
<li>DIGITS用户接口提供了DNN优化工具。主控制台列出了现有的数据库和机器上可用的先前训练好的网络模型以及正在进行的训练活动。</li>
<li>DIGITS使可视化网络和快速对比精度变得简单。你选择一个模型，DIGITS显示训练状态和精度，并提供在网络训练时或训练完毕后加载和分类图像的选项。</li>
<li>由于DIGITS运行在一个web服务器上，团队用户可以很方便地分享数据库和网络配置，以及测试和分享结果。</li>
<li>DIGITS集成了流行的Caffe deep learning framework，并支持使用cudnn进行GPU加速。</li>
</ul>
<p>尝试使用DIGITS进行模型训练后，不得不说，这个平台功能做的真心不错。</p>
<h3 id="部署测试"><a href="#部署测试" class="headerlink" title="部署测试"></a>部署测试</h3><p>官方给了基于<code>Ubuntu</code>发行版的部署指南(估计是因为ubuntu上比较好处理python的各种依赖吧)，不过官方也构建的相关的Docker image来帮助用户进行部署。用户可以<code>docker pull nvidia/digits</code>直接下载最新版本。</p>
<p>容器镜像中使用5000端口来暴露web服务，因此需要将5000端口映射出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># docker run -itd --name digits -p 5000:5000 nvidia/digits:6.0</div><div class="line"># docker logs digits </div><div class="line">  ___ ___ ___ ___ _____ ___</div><div class="line"> |   \_ _/ __|_ _|_   _/ __|</div><div class="line"> | |) | | (_ || |  | | \__ \</div><div class="line"> |___/___\___|___| |_| |___/ 6.0.0</div><div class="line"></div><div class="line">libdc1394 error: Failed to initialize libdc1394</div><div class="line">/usr/local/lib/python2.7/dist-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.</div><div class="line">  warnings.warn(&apos;Matplotlib is building the font cache using fc-list. This may take a moment.&apos;)</div><div class="line">2017-12-27 13:24:54 [INFO ] Loaded 0 jobs.</div></pre></td></tr></table></figure></p>
<p>查看日志如上环境即部署成功。</p>
<h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><p>官方也给了一份测试数据以及文档来运行模型训练。<br><a href="https://github.com/NVIDIA/DIGITS/blob/master/docs/GettingStarted.md" target="_blank" rel="external">doc</a></p>
<h4 id="下载模型数据"><a href="#下载模型数据" class="headerlink" title="下载模型数据"></a>下载模型数据</h4><p>可以登录到<code>digits</code>容器内部执行以下命令进行模型数据初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ python -m digits.download_data mnist ~/mnist</div><div class="line">Downloading url=http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz ...</div><div class="line">Downloading url=http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz ...</div><div class="line">Downloading url=http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz ...</div><div class="line">Downloading url=http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz ...</div><div class="line">Uncompressing file=train-images-idx3-ubyte.gz ...</div><div class="line">Uncompressing file=train-labels-idx1-ubyte.gz ...</div><div class="line">Uncompressing file=t10k-images-idx3-ubyte.gz ...</div><div class="line">Uncompressing file=t10k-labels-idx1-ubyte.gz ...</div><div class="line">Reading labels from /home/username/mnist/train-labels.bin ...</div><div class="line">Reading images from /home/username/mnist/train-images.bin ...</div><div class="line">Reading labels from /home/username/mnist/test-labels.bin ...</div><div class="line">Reading images from /home/username/mnist/test-images.bin ...</div><div class="line">Dataset directory is created successfully at &apos;/home/username/mnist&apos;</div><div class="line">Done after 16.722807169 seconds.</div></pre></td></tr></table></figure></p>
<p>当然如果容器内部无法访问外网，也可以将相关模型数据下载后进行解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># ls dataset/</div><div class="line">  t10k-images-idx3-ubyte.gz  t10k-labels-idx1-ubyte.gz  train-images-idx3-ubyte.gz  train-labels-idx1-ubyte.gz </div><div class="line"># docker cp dataset digits:/</div></pre></td></tr></table></figure>
<p>需要注意的是，该模型文件好像不能直接解压。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># docker exec -it digits bash</div><div class="line">root@aa3e7a2437af:/# cd dataset/</div><div class="line">root@aa3e7a2437af:/dataset# ls</div><div class="line">t10k-images-idx3-ubyte.gz  t10k-labels-idx1-ubyte.gz  train-images-idx3-ubyte.gz  train-labels-idx1-ubyte.gz</div><div class="line">root@aa3e7a2437af:/dataset# python -m digits.download_data mnist .</div><div class="line">Uncompressing file=train-images-idx3-ubyte.gz ...</div><div class="line">Uncompressing file=train-labels-idx1-ubyte.gz ...</div><div class="line">Uncompressing file=t10k-images-idx3-ubyte.gz ...</div><div class="line">Uncompressing file=t10k-labels-idx1-ubyte.gz ...</div><div class="line">Reading labels from ./train-labels.bin ...</div><div class="line">Reading images from ./train-images.bin ...</div><div class="line">Reading labels from ./test-labels.bin ...</div><div class="line">Reading images from ./test-images.bin ...</div><div class="line">Dataset directory is created successfully at &apos;.&apos;</div><div class="line">Done after 18.2706720829 seconds.</div><div class="line">root@aa3e7a2437af:/dataset#</div></pre></td></tr></table></figure>
<h4 id="使用WebApp"><a href="#使用WebApp" class="headerlink" title="使用WebApp"></a>使用WebApp</h4><p>使用浏览器访问容器宿主机的5000端口，即可看到首页数据</p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/index.png" alt="index"></p>
<p><strong>登录</strong></p>
<p>点击右上角的<code>login</code>按钮进行登录。</p>
<p><code>这里其实没有认证信息，用户随便输入就可以登录</code></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/login.png" alt="login"></p>
<p><strong>创建DataSet</strong></p>
<p>登录后点击”New Image Classification Dataset”<br>并进行相关设置。</p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/dataset.png" alt="dataset"></p>
<p>当job运行时，就可以在右侧看到运行的时间，以及结果。<br><img src="http://oyep1jupk.bkt.clouddn.com/dataset1.png" alt="dataset1"><br><img src="http://oyep1jupk.bkt.clouddn.com/dataset2.png" alt="dataset2"></p>
<p>当运行完成之后，点击左上角的<code>DIGITS</code>,可以看到创建的<code>dataset</code><br><img src="http://oyep1jupk.bkt.clouddn.com/dataset-final.png" alt="dataset-final"></p>
<p><strong>训练模型</strong></p>
<p>点击 <code>Models &gt; New Model &gt; Images &gt; Classification</code>.将引导你到<code>New Image Classification Model</code> 页面。</p>
<p>按照以下步骤进行操作</p>
<ul>
<li>在<code>Select Dataset field</code>选择 “testbiaoge” 数据集</li>
<li>在<code>Standard Networks</code>窗口选择<code>LeNet</code>网络</li>
<li>填写GPU卡数量以及模型名称</li>
<li>点击<code>Create</code>按钮进行创建</li>
</ul>
<p><img src="http://oyep1jupk.bkt.clouddn.com/model.png" alt="model-1"><br><img src="http://oyep1jupk.bkt.clouddn.com/model2.png" alt="model-2"></p>
<p>在训练过程中用户可以看到悬链环境以及训练时间等相关信息。</p>
<p>训练完成的状态：<br><img src="http://oyep1jupk.bkt.clouddn.com/model-train.png" alt="model-train"></p>
<p>为了测试这个模型，可以拉到页面最底部</p>
<ul>
<li><p>点击<code>Upload image</code> 按钮选择一个文件，测试过程中选择<code>/dataset/test/2/00035.png</code></p>
</li>
<li><p>或者在网络上找一张图片，黏贴URL到<code>Image URL</code></p>
</li>
<li><p>选中<code>Show visualizations and statistics</code></p>
</li>
<li><p>点击<code>Classify One</code></p>
</li>
</ul>
<p>在页面顶部，展示了五个分类以及相关的值。<code>DIGITS</code>也提供了一些可视化以及网络中每个层的权重和激活统计信息。</p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/test-model-1.png" alt="test-model"></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/test-model.png" alt="test-model2"></p>
<p>查看最终任务运行的过程信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">2017-12-29 06:50:54 [20171229-065052-5cc9] [INFO ] Infer Model task started.</div><div class="line">2017-12-29 06:50:54 [20171229-065052-5cc9] [INFO ] Task subprocess args: &quot;/usr/bin/python /usr/local/lib/python2.7/dist-packages/digits/tools/inference.py /jobs/20171229-065052-5cc9/tmpctzfnI.txt /jobs/20171229-065052-5cc9 20171229-064432-4c8a --jobs_dir=/jobs --epoch=30.0 --layers=all --gpu=0&quot;</div><div class="line">2017-12-29 06:50:54 [20171229-065052-5cc9] [WARNING] Infer Model unrecognized output: libdc1394 error: Failed to initialize libdc1394</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Infer Model task completed.</div><div class="line">2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Job complete.</div><div class="line">2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Job deleted.</div></pre></td></tr></table></figure></p>
<p>至此，使用NVIDIA-DIGITS已经完成了一个模型训练。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DIGITS简介&quot;&gt;&lt;a href=&quot;#DIGITS简介&quot; class=&quot;headerlink&quot; title=&quot;DIGITS简介&quot;&gt;&lt;/a&gt;DIGITS简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/NVIDIA/DIGITS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DIGITS&lt;/a&gt;: Deep Learning GPU Training System1，是由英伟达（NVIDIA）公司开发的第一个交互式深度学习GPU训练系统。目的在于整合现有的Deep Learning开发工具，实现深度神经网络（Deep Neural Network，DNN）设计、训练和可视化等任务变得简单化。DIGITS是基于浏览器的接口，因而通过实时的网络行为的可视化，可以快速设计最优的DNN。DIGITS是开源软件，可在GitHub上找到，因而开发人员可以扩展和自定义DIGITS。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="nvidia" scheme="http://yoursite.com/tags/nvidia/"/>
    
      <category term="nvidia-digits" scheme="http://yoursite.com/tags/nvidia-digits/"/>
    
      <category term="deeplearning" scheme="http://yoursite.com/tags/deeplearning/"/>
    
  </entry>
  
  <entry>
    <title>回顾2017-展望2018</title>
    <link href="http://yoursite.com/2018/01/01/%E5%9B%9E%E9%A1%BE2017-%E5%B1%95%E6%9C%9B2018/"/>
    <id>http://yoursite.com/2018/01/01/回顾2017-展望2018/</id>
    <published>2018-01-01T11:29:09.000Z</published>
    <updated>2018-01-02T05:43:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年，除工作之外的时间估计更多的都花费在跑步上了。从4月15日的TNF50，到7月14日的崇礼越野50，再到9月10的太原国际马拉松和9月17日的北京国际马拉松，以及11月4号陪我宇神奥森100的最后30公里。当然，跑量不算多，但是和忙碌的工作穿插起来，也构成了2017完美的一年，这一年以跑步开始以跑步结束，收获乐趣的同时也让我成长了更多。2017，首先感谢我的家人朋友，我的京东跑友以及我的同事领导们，最后也要感谢在你们指导下的我自己，是你们的指导、包容和支持，让我在这一年里收获良多。<br><a id="more"></a></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/2018-run.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/2018.png" alt=""></p>
<p>2018年，我的个人活动中心依旧会是跑步，但是我想尝试更多，挑战不同难度的越野比赛，以此来不断磨练自己的心性；同时我会拼劲全力来做好与自己本职工作相关的工作，结合场景为团队创造价值，为什么是拼劲全力呢？因为在我眼里，工作对于我来说远远不是最终要的，生活才是，所以我不会以身试险，经常去拿自己的身体换取工作的回报，当然偶尔的几次还是可以的，毕竟我爱我做的工作。所以最后，我会将跑步和工作之外的时间都投入到家庭和生活之中(好像也没有太多时间了哦)。</p>
<h3 id="回顾2017"><a href="#回顾2017" class="headerlink" title="回顾2017"></a>回顾2017</h3><p><a href="https://xxbandy.github.io/2017/11/05/%E6%88%91%E7%9A%84%E8%B6%8A%E9%87%8E%E5%85%83%E5%B9%B4/" target="_blank" rel="external">马拉松的回顾</a>之前已经总结了，2017年在工作以及个人职业生涯规划上的时间投入是比较多的，所以好像除了工作以及职业生涯方面的回顾和思考好像也么有什么了。</p>
<h4 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h4><p>2017年上半年，在外面参加的技术大会会比较多，一方面是因为想接触一些技术界的大神老师们，另外一方面也是想学习学习，学习一些企业IT架构以及对于某种业务场景下，某种技术组合的解决方案最终产生的价值效益比。</p>
<p>虽然过去的一年在企业容器化道路上没有一些非常成功的案例实践，但是在过程中自己也摸索出一些通用的门道，包括一些<code>业务场景</code>的技术选型，业务<code>价值</code>的交付链以及<code>用户友好性</code>的考虑，同时在对待项目过程中的及时反馈和向上管理等多方面的问题。但是说这么多，你可能会觉得很虚，其实真的很虚，以上涉及到的业务场景、价值交付、用户以及项目管理中的一些东西，说起来其实很简单，但是实际做起来有多难想必只有亲身经历过的人才知道，因为整个项目过程中可能涉及的是一个小生态，而不仅仅是项目那么简单。</p>
<p>2017年，我面过几个人，也被几个人面过，面完之后也的确给我的感觉是很虚。可能也是得益于当前各种技术发展的太快并且各种对应的开源软件层出不穷吧，大家普遍的感觉就是，只要这个东西还不错，能解决一些问题，然后就拿来就用，至于这个东西底层是怎么实现的，如何去进行优化并结合其他周边的业务场景，考虑这个的人并不是很多，所以最后造成的结果就是，维护一些项目可能需要各种各样的工具，最终被很多东西裹挟(其实这也就解释了为什么很多大厂都是基于某个技术进行开发适合自己的产品了)。当然说这么多，我想表达的只是：</p>
<p><strong>2018年，我会更加专注于去做某一件事，更加深入的去研究某一个技术以及最基础的知识，如果你还没有这样做，我建议一定要腾出来时间去专注于某一件事的研究，我相信那样会有惊喜发生。</strong></p>
<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>17年，同样有一件事情没有做好，那就是写作(暂且叫做写作吧)和分享，最早维护了一个微信公众号<code>逼格运维说</code>，主要用来分享我个人经历思考以及运维方面的知识，后来由于个人经历方面的原因，将运维方面的知识迁移到简书<code>BG运维</code>上，来分享运维相关的技术文章，而后个人微信公众号就没再分享过了，一方面因为微信公众号内容的排版问题，另外一方面感觉实在没有去深入思考某些相关的东西。到后来，索性自己维护一个个人主页<code>xxbandy.github.io</code>,基于<code>Markdown</code>的语法,排版方便也能进行历史文章的修改，因此就将当初想在公众号<code>逼格运维说</code>做的事情慢慢迁移到个人主页(xxbandy.github.io)了。这里可以向大家推荐几个Markdown编辑器，免费的可以选择<code>有道云笔记</code>，付费用户可以选择<code>为知笔记</code>，还有一款免费的Markdown语法PPT编辑器<code>Marp</code>，经过多次尝试使用，个人感觉上述三个软件还是不错的。</p>
<p>那我为什么要做这件事呢？一方面是想通过文字的方式记录自己的实践和思考，未来回过头来有反思和优化依据;另外一方面是想培养自己书写总结的能力。而后来我发现通过这种写作的方式很能提高工作中的沟通效率，在工作中做到<code>事必有果</code>，文档记录是一个最简单且高效的方式了。</p>
<p><strong>所以，2018年，我会尽量将自己的工作以及项目结论进行文档化记录一方面巩固自己，另外一方面提高团队整体协作效率</strong></p>
<h4 id="适合"><a href="#适合" class="headerlink" title="适合"></a>适合</h4><p>老哥以前经常给我说一句话”适合自己的才是最好的”，我觉得这句话放在那里都是最合适不过的。而像我们搞运维的也一样，如何站在业务方的角度去考虑问题，如何去深挖当前业务痛点并结合特定技术来提供解决方案，这些对于最终结果的好坏都是致命的因素。举个很简单的例子，如果按照容器以及周边生态本身的技术特性去推动企业应用容器化改造，这样的效果肯定是大打折扣的，因为不论是按照容器化或者微服务化的思想，传统的业务架构都是存在一定差异性的，只从技术的角度去推动，那么不仅在时间上不乐观，而且很有可能因为某一次失误失去所有机会。只有根据当前业务场景以及实际痛点去调整改造技术方案，才有可能最大程度的推进容器化项目改造。我承认，我不是一个忠实的技术拥护者，因为我认为如果某个技术不能找到合适的场景，那么该技术本身是没有价值的，而映射到企业内部，如果你做出来一款没有合适场景的软件系统，不仅仅该产品没有价值，当没有人使用它的时候，想必开发者本身也有点灰心了吧，至少我有过这种感觉。</p>
<p><strong>那，很明显了，2018年做项目和产品，我可能不会贸然行动了，至少要搞清楚业务的场景以及痛点是什么，也就是不要着急去做技术架构，可以先去了解业务和产品架构，而后再规划技术产品。一定要结合场景去做产品，因为适合业务场景的才是最好的产品。</strong></p>
<p>2017年，个人感觉工作上除了经历比较多，犯错比较多之外，好像没有什么做的比较成功的地方，但本身这种经历对于我而言已经是莫大的财富了，这也要感谢我领导超哥的支持，以及团队其他小伙伴们的包容和理解了。</p>
<h3 id="展望2018"><a href="#展望2018" class="headerlink" title="展望2018"></a>展望2018</h3><p><img src="http://oyep1jupk.bkt.clouddn.com/8.png" alt=""></p>
<p>突然很喜欢8这个数字，不仅仅是它有”fa”的谐音，也不仅仅是因为昨天跑”2018”只剩下”8”的图案，而是因为对”8”有了另外一种解读—“双循环结构”，不断更新迭代的循环系统会让系统本身更加健壮有力。</p>
<p>2018，专注于自己想做的并结合实际的业务场景踏实去做，且要不断积累自己的各方面能力。金融领域的运维并不只是有”稳定，效率，成本”,”质量和安全”可能更加重要，所以专注于某一个点精耕细作，结合金融领域的运维继续努力去做事。</p>
<p>对了，得什么不要得病，2018，身体健康很重要。祝大家在新的一年里身体健康，888！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年，除工作之外的时间估计更多的都花费在跑步上了。从4月15日的TNF50，到7月14日的崇礼越野50，再到9月10的太原国际马拉松和9月17日的北京国际马拉松，以及11月4号陪我宇神奥森100的最后30公里。当然，跑量不算多，但是和忙碌的工作穿插起来，也构成了2017完美的一年，这一年以跑步开始以跑步结束，收获乐趣的同时也让我成长了更多。2017，首先感谢我的家人朋友，我的京东跑友以及我的同事领导们，最后也要感谢在你们指导下的我自己，是你们的指导、包容和支持，让我在这一年里收获良多。&lt;br&gt;
    
    </summary>
    
      <category term="生活思考" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/"/>
    
    
      <category term="2018" scheme="http://yoursite.com/tags/2018/"/>
    
      <category term="规划" scheme="http://yoursite.com/tags/%E8%A7%84%E5%88%92/"/>
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Golang中GBK和UTF-8格式互相转换</title>
    <link href="http://yoursite.com/2017/12/24/Golang%E4%B8%ADGBK%E5%92%8CUTF-8%E6%A0%BC%E5%BC%8F%E7%94%BB%E5%83%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/12/24/Golang中GBK和UTF-8格式画像转换/</id>
    <published>2017-12-24T09:36:14.000Z</published>
    <updated>2018-01-01T11:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>直接上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @File Name: gb2312-utf8.go</div><div class="line"> * @Author:</div><div class="line"> * @Email:</div><div class="line"> * @Create Date: 2017-12-18 14:12:25</div><div class="line"> * @Last Modified: 2017-12-18 14:12:00</div><div class="line"> * @Description:</div><div class="line"> */</div><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;bytes&quot;</div><div class="line">    &quot;golang.org/x/text/encoding/simplifiedchinese&quot;</div><div class="line">    &quot;golang.org/x/text/transform&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func GbkToUtf8(s []byte) ([]byte, error) &#123;</div><div class="line">    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())</div><div class="line">    d, e := ioutil.ReadAll(reader)</div><div class="line">    if e != nil &#123;</div><div class="line">        return nil, e</div><div class="line">    &#125;</div><div class="line">    return d, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func Utf8ToGbk(s []byte) ([]byte, error) &#123;</div><div class="line">    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewEncoder())</div><div class="line">    d, e := ioutil.ReadAll(reader)</div><div class="line">    if e != nil &#123;</div><div class="line">        return nil, e</div><div class="line">    &#125;</div><div class="line">    return d, nil</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line"></div><div class="line">    s := &quot;GBK 与 UTF-8 编码转换测试&quot;</div><div class="line">    gbk, err := Utf8ToGbk([]byte(s))</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(err)</div><div class="line">    &#125; else &#123;</div><div class="line">        fmt.Println(string(gbk))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    utf8, err := GbkToUtf8(gbk)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(err)</div><div class="line">    &#125; else &#123;</div><div class="line">        fmt.Println(string(utf8))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run gbktoutf-8.go</div><div class="line">GBK �� UTF-8 ����ת������</div><div class="line">GBK 与 UTF-8 编码转换测试</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接上代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Golang正则模块使用</title>
    <link href="http://yoursite.com/2017/12/24/Golang%E6%AD%A3%E5%88%99%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/12/24/Golang正则模块使用/</id>
    <published>2017-12-24T08:39:14.000Z</published>
    <updated>2017-12-24T09:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发过程中会遇到一些字符串匹配相关的内容，正好去大概学习了下Golang中的<code>regexp</code>模块。因为目前正则模块对我来说更多的就是去匹配并处理字符串的，因此目前主要关注几个返回为<code>string</code>类型的方法。<br><a id="more"></a></p>
<p><strong><code>regexp</code>模块的结构体和方法定义</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//正则结构体</div><div class="line">type Regexp struct &#123;</div><div class="line">        // contains filtered or unexported fields</div><div class="line">&#125;</div><div class="line"></div><div class="line">//初始化结构体对象的方法</div><div class="line">func Compile(expr string) (*Regexp, error)</div><div class="line">func CompilePOSIX(expr string) (*Regexp, error)</div><div class="line">func MustCompile(str string) *Regexp</div><div class="line">func MustCompilePOSIX(str string) *Regexp</div><div class="line"></div><div class="line"></div><div class="line">//结构体方法.常用的几个</div><div class="line">//在字符串s中查找完全匹配正则表达式re的字符串.如果匹配到就停止不进行全部匹配，如果匹配不到就输出空字符串</div><div class="line">func (re *Regexp) FindString(s string) string</div><div class="line"></div><div class="line">//在字符串s中匹配re表达式，n表示匹配的次数，-1表示匹配整个字符串。返回字符串切片</div><div class="line">func (re *Regexp) FindAllString(s string, n int) []string</div><div class="line"></div><div class="line">//在src中匹配re，并替换为repl，该种方式中repl中的$符号会展开实际的变量，通常用在回溯查找中</div><div class="line">func (re *Regexp) ReplaceAllString(src, repl string) string</div><div class="line"></div><div class="line">//在src中匹配re，并替换为repl,该方法会按照repl中的字面意思进行替换，不支持高级变量匹配，比如回溯等等</div><div class="line">func (re *Regexp) ReplaceAllLiteralString(src, repl string) string</div><div class="line"> </div><div class="line"> </div><div class="line">//在字符串中是否匹配到re定义的字符串，匹配返回true</div><div class="line">func (re *Regexp) MatchString(s string) bool</div></pre></td></tr></table></figure></p>
<p><strong>简单示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">$ cat regexp-test.go</div><div class="line">/**</div><div class="line"> * @File Name: test.go</div><div class="line"> * @Author:</div><div class="line"> * @Email:</div><div class="line"> * @Create Date: 2017-12-24 15:12:31</div><div class="line"> * @Last Modified: 2017-12-24 16:12:12</div><div class="line"> * @Description:</div><div class="line"> */</div><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">	&quot;fmt&quot;</div><div class="line">	&quot;regexp&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">  testString := &quot;k8s-test-pod-12343k811sadsxsakxz-test-k8s-container.k8s-@xxbandy.github.io&quot;</div><div class="line">	re := regexp.MustCompile(&quot;k8s?&quot;)</div><div class="line">  fmt.Println(&quot;src string:&quot;,testString)</div><div class="line">  fmt.Println(&quot;regular expression:&quot;,re)</div><div class="line"></div><div class="line">  fmt.Println(&quot;FindAllString matching all:&quot;,re.FindAllString(testString,-1))</div><div class="line">  fmt.Println(&quot;FindAllString matching twice:&quot;,re.FindAllString(testString,2))</div><div class="line">  fmt.Println(&quot;FindString:&quot;,re.FindString(testString))</div><div class="line">  fmt.Println(&quot;ReplaceAllString:&quot;,re.ReplaceAllString(testString,&quot;biaoge&quot;))</div><div class="line">  fmt.Println(&quot;ReplaceAllLiteralString:&quot;,re.ReplaceAllLiteralString(testString,&quot;BIAOGE&quot;))</div><div class="line">  fmt.Println(&quot;Match String:&quot;,re.MatchString(testString))</div><div class="line">&#125;</div><div class="line"></div><div class="line">$ go run regexp-test.go</div><div class="line">src string: k8s-test-pod-12343k811sadsxsakxz-test-k8s-container.k8s-@xxbandy.github.io</div><div class="line">regular expression: k8s?</div><div class="line">FindAllString matching all: [k8s k8 k8s k8s]</div><div class="line">FindAllString matching twice: [k8s k8]</div><div class="line">FindString: k8s</div><div class="line">ReplaceAllString: biaoge-test-pod-12343biaoge11sadsxsakxz-test-biaoge-container.biaoge-@xxbandy.github.io</div><div class="line">ReplaceAllLiteralString: BIAOGE-test-pod-12343BIAOGE11sadsxsakxz-test-BIAOGE-container.BIAOGE-@xxbandy.github.io</div><div class="line">Match String: true</div></pre></td></tr></table></figure></p>
<p>不论是哪种语言的正则模块，个人认为语法都不是最重要的，最重要我认为还是正则表达式本身，如果对正则表达式本身认识比较深的话，不论用哪种语言工具都可以很灵活的处理各种业务场景。这里附上一篇当年写的正则表达式相关的<a href="https://my.oschina.net/xxbAndy/blog/370806" target="_blank" rel="external">文章</a></p>
<p>看到另外一篇文章的正则总结的挺好，分享下来.<br><a href="http://blog.csdn.net/zfy1355/article/details/52959803" target="_blank" rel="external">http://blog.csdn.net/zfy1355/article/details/52959803</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发过程中会遇到一些字符串匹配相关的内容，正好去大概学习了下Golang中的&lt;code&gt;regexp&lt;/code&gt;模块。因为目前正则模块对我来说更多的就是去匹配并处理字符串的，因此目前主要关注几个返回为&lt;code&gt;string&lt;/code&gt;类型的方法。&lt;br&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="regexp" scheme="http://yoursite.com/tags/regexp/"/>
    
  </entry>
  
  <entry>
    <title>Golang读写文件操作</title>
    <link href="http://yoursite.com/2017/12/17/Golang%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/12/17/Golang读写文件操作/</id>
    <published>2017-12-17T15:25:25.000Z</published>
    <updated>2017-12-17T15:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用Golang进行文件读写的过程中，遇到几个细节问题导致程序写入数据时有一定脏数据的残留，最后发现是使用os.OpenFile在进行文件操作的时候没有使用正确的flag造成的。因此专门去学习了下Golang中读写文件的几种方式方法,在此记录下一些简单的操作，防止以后遗忘。</p>
<a id="more"></a>
<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>使用golang语言去读取一个文件默认会有多种方式，这里主要介绍以下几种。</p>
<h4 id="使用ioutil直接读取"><a href="#使用ioutil直接读取" class="headerlink" title="使用ioutil直接读取"></a>使用<code>ioutil</code>直接读取</h4><p>需要引入<code>io/ioutil</code>包，该包默认拥有以下函数供用户调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func NopCloser(r io.Reader) io.ReadCloser</div><div class="line">func ReadAll(r io.Reader) ([]byte, error)</div><div class="line">func ReadDir(dirname string) ([]os.FileInfo, error)</div><div class="line">func ReadFile(filename string) ([]byte, error)</div><div class="line">func TempDir(dir, prefix string) (name string, err error)</div><div class="line">func TempFile(dir, prefix string) (f *os.File, err error)</div><div class="line">func WriteFile(filename string, data []byte, perm os.FileMode) error</div></pre></td></tr></table></figure>
<p>读文件，我们可以看以下三个函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//从一个io.Reader类型中读取内容直到返回错误或者EOF时返回读取的数据，当err == nil时，数据成功读取到[]byte中</div><div class="line">//ReadAll函数被定义为从源中读取数据直到EOF，它是不会去从返回数据中去判断EOF来作为读取成功的依据</div><div class="line">func ReadAll(r io.Reader) ([]byte, error)</div><div class="line"></div><div class="line">//读取一个目录，并返回一个当前目录下的文件对象列表和错误信息</div><div class="line">func ReadDir(dirname string) ([]os.FileInfo, error)</div><div class="line"></div><div class="line">//读取文件内容，并返回[]byte数据和错误信息。err == nil时，读取成功</div><div class="line">func ReadFile(filename string) ([]byte, error)</div></pre></td></tr></table></figure></p>
<p>读取文件示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ cat readfile.go</div><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;strings&quot;</div><div class="line">)</div><div class="line">func main() &#123;</div><div class="line">   Ioutil(&quot;mytestfile.txt&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">func Ioutil(name string) &#123;</div><div class="line">    if contents,err := ioutil.ReadFile(name);err == nil &#123;</div><div class="line">        //因为contents是[]byte类型，直接转换成string类型后会多一行空格,需要使用strings.Replace替换换行符</div><div class="line">        result := strings.Replace(string(contents),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">        fmt.Println(result)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">$ go run readfile.go</div><div class="line">xxbandy.github.io @by Andy_xu</div></pre></td></tr></table></figure></p>
<h4 id="借助os-Open进行读取文件"><a href="#借助os-Open进行读取文件" class="headerlink" title="借助os.Open进行读取文件"></a>借助<code>os.Open</code>进行读取文件</h4><p>由于<code>os.Open</code>是打开一个文件并返回一个文件对象，因此其实可以结合<code>ioutil.ReadAll(r io.Reader)</code>来进行读取。<br><code>io.Reader</code>其实是一个包含<code>Read</code>方法的接口类型，而文件对象本身是实现了了<code>Read</code>方法的。</p>
<p>我们先来看下<code>os.Open</code>家族的相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//打开一个需要被读取的文件，如果成功读取，返回的文件对象将可用被读取，该函数默认的权限为O_RDONLY，也就是只对文件有只读权限。如果有错误，将返回*PathError类型</div><div class="line">func Open(name string) (*File, error)</div><div class="line"></div><div class="line">//大部分用户会选择该函数来代替Open or Create函数。该函数主要用来指定参数(os.O_APPEND|os.O_CREATE|os.O_WRONLY)以及文件权限(0666)来打开文件，如果打开成功返回的文件对象将被用作I/O操作</div><div class="line">func OpenFile(name string, flag int, perm FileMode) (*File, error)</div></pre></td></tr></table></figure>
<p>使用<code>os.Open</code>家族函数和<code>ioutil.ReadAll()</code>读取文件示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func OsIoutil(name string) &#123;</div><div class="line">      if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">      //if fileObj,err := os.OpenFile(name,os.O_RDONLY,0644); err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        if contents,err := ioutil.ReadAll(fileObj); err == nil &#123;</div><div class="line">            result := strings.Replace(string(contents),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">            fmt.Println(&quot;Use os.Open family functions and ioutil.ReadAll to read a file contents:&quot;,result)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 在main函数中调用OsIoutil(name)函数就可以读取文件内容了</div><div class="line">$ go run readfile.go</div><div class="line">Use os.Open family functions and ioutil.ReadAll to read a file contents: xxbandy.github.io @by Andy_xu</div></pre></td></tr></table></figure></p>
<p>然而上述方式会比较繁琐一些，因为使用了<code>os</code>的同时借助了<code>ioutil</code>,但是在读取大文件的时候还是比较有优势的。不过读取小文件可以直接使用文件对象的一些方法。</p>
<p>不论是上边说的<code>os.Open</code>还是<code>os.OpenFile</code>他们最终都返回了一个<code>*File</code>文件对象，而该文件对象默认是有很多方法的，其中读取文件的方法有如下几种:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//从文件对象中读取长度为b的字节，返回当前读到的字节数以及错误信息。因此使用该方法需要先初始化一个符合内容大小的空的字节列表。读取到文件的末尾时，该方法返回0，io.EOF</div><div class="line">func (f *File) Read(b []byte) (n int, err error)</div><div class="line"></div><div class="line">//从文件的off偏移量开始读取长度为b的字节。返回读取到字节数以及错误信息。当读取到的字节数n小于想要读取字节的长度len(b)的时候，该方法将返回非空的error。当读到文件末尾时，err返回io.EOF</div><div class="line">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</div></pre></td></tr></table></figure></p>
<p>使用文件对象的<code>Read</code>方法读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func FileRead(name string) &#123;</div><div class="line">    if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        //在定义空的byte列表时尽量大一些，否则这种方式读取内容可能造成文件读取不完整</div><div class="line">        buf := make([]byte, 1024)</div><div class="line">        if n,err := fileObj.Read(buf);err == nil &#123;</div><div class="line">               fmt.Println(&quot;The number of bytes read:&quot;+strconv.Itoa(n),&quot;Buf length:&quot;+strconv.Itoa(len(buf)))</div><div class="line">               result := strings.Replace(string(buf),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">               fmt.Println(&quot;Use os.Open and File&apos;s Read method to read a file:&quot;,result)</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用os-Open和bufio-Reader读取文件内容"><a href="#使用os-Open和bufio-Reader读取文件内容" class="headerlink" title="使用os.Open和bufio.Reader读取文件内容"></a>使用<code>os.Open</code>和<code>bufio.Reader</code>读取文件内容</h4><p><code>bufio</code>包实现了缓存IO,它本身包装了<code>io.Reader</code>和<code>io.Writer</code>对象，创建了另外的Reader和Writer对象，不过该种方式是带有缓存的，因此对于文本I/O来说，该包是提供了一些便利的。</p>
<p>先看下<code>bufio</code>模块下的相关的<code>Reader</code>函数方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//首先定义了一个用来缓冲io.Reader对象的结构体，同时该结构体拥有以下相关的方法</div><div class="line">type Reader struct &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//NewReader函数用来返回一个默认大小buffer的Reader对象(默认大小好像是4096) 等同于NewReaderSize(rd,4096)</div><div class="line">func NewReader(rd io.Reader) *Reader</div><div class="line"></div><div class="line">//该函数返回一个指定大小buffer(size最小为16)的Reader对象，如果 io.Reader参数已经是一个足够大的Reader，它将返回该Reader</div><div class="line">func NewReaderSize(rd io.Reader, size int) *Reader</div><div class="line"></div><div class="line"></div><div class="line">//该方法返回从当前buffer中能被读到的字节数</div><div class="line">func (b *Reader) Buffered() int</div><div class="line"></div><div class="line">//Discard方法跳过后续的 n 个字节的数据，返回跳过的字节数。如果0 &lt;= n &lt;= b.Buffered(),该方法将不会从io.Reader中成功读取数据。</div><div class="line">func (b *Reader) Discard(n int) (discarded int, err error)</div><div class="line"></div><div class="line">//Peekf方法返回缓存的一个切片，该切片只包含缓存中的前n个字节的数据</div><div class="line">func (b *Reader) Peek(n int) ([]byte, error)</div><div class="line"></div><div class="line">//把Reader缓存对象中的数据读入到[]byte类型的p中，并返回读取的字节数。读取成功，err将返回空值</div><div class="line">func (b *Reader) Read(p []byte) (n int, err error)</div><div class="line"></div><div class="line">//返回单个字节，如果没有数据返回err</div><div class="line">func (b *Reader) ReadByte() (byte, error)</div><div class="line"></div><div class="line">//该方法在b中读取delimz之前的所有数据，返回的切片是已读出的数据的引用，切片中的数据在下一次的读取操作之前是有效的。如果未找到delim，将返回查找结果并返回nil空值。因为缓存的数据可能被下一次的读写操作修改，因此一般使用ReadBytes或者ReadString，他们返回的都是数据拷贝</div><div class="line">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</div><div class="line"></div><div class="line">//功能同ReadSlice，返回数据的拷贝</div><div class="line">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</div><div class="line"></div><div class="line">//功能同ReadBytes,返回字符串</div><div class="line">func (b *Reader) ReadString(delim byte) (string, error)</div><div class="line"></div><div class="line">//该方法是一个低水平的读取方式，一般建议使用ReadBytes(&apos;\n&apos;) 或 ReadString(&apos;\n&apos;)，或者使用一个 Scanner来代替。ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片，用于读取一行数据，不包括行尾标记（\n 或 \r\n）</div><div class="line">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</div><div class="line"></div><div class="line">//读取单个UTF-8字符并返回一个rune和字节大小</div><div class="line">func (b *Reader) ReadRune() (r rune, size int, err error)</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">func BufioRead(name string) &#123;</div><div class="line">    if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空</div><div class="line">        reader := bufio.NewReader(fileObj)</div><div class="line">        //使用ReadString(delim byte)来读取delim以及之前的数据并返回相关的字符串.</div><div class="line">        if result,err := reader.ReadString(byte(&apos;@&apos;));err == nil &#123;</div><div class="line">            fmt.Println(&quot;使用ReadSlince相关方法读取内容:&quot;,result)</div><div class="line">        &#125;</div><div class="line">        //注意:上述ReadString已经将buffer中的数据读取出来了，下面将不会输出内容</div><div class="line">        //需要注意的是，因为是将文件内容读取到[]byte中，因此需要对大小进行一定的把控</div><div class="line">        buf := make([]byte,1024)</div><div class="line">        //读取Reader对象中的内容到[]byte类型的buf中</div><div class="line">        if n,err := reader.Read(buf); err == nil &#123;</div><div class="line">            fmt.Println(&quot;The number of bytes read:&quot;+strconv.Itoa(n))</div><div class="line">            //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉</div><div class="line">            fmt.Println(&quot;Use bufio.NewReader and os.Open read file contents to a []byte:&quot;,string(buf))</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="读文件所有方式示例"><a href="#读文件所有方式示例" class="headerlink" title="读文件所有方式示例"></a>读文件所有方式示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @File Name: readfile.go</div><div class="line"> * @Author:</div><div class="line"> * @Email:</div><div class="line"> * @Create Date: 2017-12-16 16:12:01</div><div class="line"> * @Last Modified: 2017-12-17 12:12:02</div><div class="line"> * @Description:读取指定文件的几种方法，需要注意的是[]byte类型在转换成string类型的时候，都会在最后多一行空格，需要使用result := strings.Replace(string(contents),&quot;\n&quot;,&quot;&quot;,1) 方式替换换行符</div><div class="line"> */</div><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;strings&quot;</div><div class="line">    &quot;os&quot;</div><div class="line">    &quot;strconv&quot;</div><div class="line">    &quot;bufio&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">   Ioutil(&quot;mytestfile.txt&quot;)</div><div class="line">   OsIoutil(&quot;mytestfile.txt&quot;)</div><div class="line">   FileRead(&quot;mytestfile.txt&quot;)</div><div class="line">   BufioRead(&quot;mytestfile.txt&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">func Ioutil(name string) &#123;</div><div class="line">    if contents,err := ioutil.ReadFile(name);err == nil &#123;</div><div class="line">        //因为contents是[]byte类型，直接转换成string类型后会多一行空格,需要使用strings.Replace替换换行符</div><div class="line">        result := strings.Replace(string(contents),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">        fmt.Println(&quot;Use ioutil.ReadFile to read a file:&quot;,result)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">func OsIoutil(name string) &#123;</div><div class="line">      if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">      //if fileObj,err := os.OpenFile(name,os.O_RDONLY,0644); err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        if contents,err := ioutil.ReadAll(fileObj); err == nil &#123;</div><div class="line">            result := strings.Replace(string(contents),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">            fmt.Println(&quot;Use os.Open family functions and ioutil.ReadAll to read a file :&quot;,result)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">func FileRead(name string) &#123;</div><div class="line">    if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        //在定义空的byte列表时尽量大一些，否则这种方式读取内容可能造成文件读取不完整</div><div class="line">        buf := make([]byte, 1024)</div><div class="line">        if n,err := fileObj.Read(buf);err == nil &#123;</div><div class="line">               fmt.Println(&quot;The number of bytes read:&quot;+strconv.Itoa(n),&quot;Buf length:&quot;+strconv.Itoa(len(buf)))</div><div class="line">               result := strings.Replace(string(buf),&quot;\n&quot;,&quot;&quot;,1)</div><div class="line">               fmt.Println(&quot;Use os.Open and File&apos;s Read method to read a file:&quot;,result)</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func BufioRead(name string) &#123;</div><div class="line">    if fileObj,err := os.Open(name);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空</div><div class="line">        reader := bufio.NewReader(fileObj)</div><div class="line">        //使用ReadString(delim byte)来读取delim以及之前的数据并返回相关的字符串.</div><div class="line">        if result,err := reader.ReadString(byte(&apos;@&apos;));err == nil &#123;</div><div class="line">            fmt.Println(&quot;使用ReadSlince相关方法读取内容:&quot;,result)</div><div class="line">        &#125;</div><div class="line">        //注意:上述ReadString已经将buffer中的数据读取出来了，下面将不会输出内容</div><div class="line">        //需要注意的是，因为是将文件内容读取到[]byte中，因此需要对大小进行一定的把控</div><div class="line">        buf := make([]byte,1024)</div><div class="line">        //读取Reader对象中的内容到[]byte类型的buf中</div><div class="line">        if n,err := reader.Read(buf); err == nil &#123;</div><div class="line">            fmt.Println(&quot;The number of bytes read:&quot;+strconv.Itoa(n))</div><div class="line">            //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉</div><div class="line">            fmt.Println(&quot;Use bufio.NewReader and os.Open read file contents to a []byte:&quot;,string(buf))</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>那么上述几种方式来读取文件的方式也支持文件的写入，相关的方法如下:</p>
<h4 id="使用ioutil包进行文件写入"><a href="#使用ioutil包进行文件写入" class="headerlink" title="使用ioutil包进行文件写入"></a>使用<code>ioutil</code>包进行文件写入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 写入[]byte类型的data到filename文件中，文件权限为perm</div><div class="line">func WriteFile(filename string, data []byte, perm os.FileMode) error</div></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">$ cat writefile.go</div><div class="line">/**</div><div class="line"> * @File Name: writefile.go</div><div class="line"> * @Author:</div><div class="line"> * @Email:</div><div class="line"> * @Create Date: 2017-12-17 12:12:09</div><div class="line"> * @Last Modified: 2017-12-17 12:12:30</div><div class="line"> * @Description:使用多种方式将数据写入文件</div><div class="line"> */</div><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">      name := &quot;testwritefile.txt&quot;</div><div class="line">      content := &quot;Hello, xxbandy.github.io!\n&quot;</div><div class="line">      WriteWithIoutil(name,content)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用ioutil.WriteFile方式写入文件,是将[]byte内容写入文件,如果content字符串中没有换行符的话，默认就不会有换行符</div><div class="line">func WriteWithIoutil(name,content string) &#123;</div><div class="line">    data :=  []byte(content)</div><div class="line">    if ioutil.WriteFile(name,data,0644) == nil &#123;</div><div class="line">        fmt.Println(&quot;写入文件成功:&quot;,content)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line"># 会有换行符    </div><div class="line">$ go run writefile.go</div><div class="line">写入文件成功: Hello, xxbandy.github.io!</div></pre></td></tr></table></figure></p>
<h4 id="使用os-Open相关函数进行文件写入"><a href="#使用os-Open相关函数进行文件写入" class="headerlink" title="使用os.Open相关函数进行文件写入"></a>使用<code>os.Open</code>相关函数进行文件写入</h4><p>因为<code>os.Open</code>系列的函数会打开文件，并返回一个文件对象指针，而该文件对象是一个定义的结构体，拥有一些相关写入的方法。</p>
<p>文件对象结构体以及相关写入文件的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//写入长度为b字节切片到文件f中，返回写入字节号和错误信息。当n不等于len(b)时，将返回非空的err</div><div class="line">func (f *File) Write(b []byte) (n int, err error)</div><div class="line">//在off偏移量出向文件f写入长度为b的字节</div><div class="line">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</div><div class="line">//类似于Write方法，但是写入内容是字符串而不是字节切片</div><div class="line">func (f *File) WriteString(s string) (n int, err error)</div></pre></td></tr></table></figure></p>
<p><code>注意：</code>使用WriteString()j进行文件写入发现经常新内容写入时无法正常覆盖全部新内容。(是因为字符串长度不一样)</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//使用os.OpenFile()相关函数打开文件对象，并使用文件对象的相关方法进行文件写入操作</div><div class="line">func WriteWithFileWrite(name,content string)&#123;</div><div class="line">    fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_TRUNC,0644)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(&quot;Failed to open the file&quot;,err.Error())</div><div class="line">        os.Exit(2)</div><div class="line">    &#125;</div><div class="line">    defer fileObj.Close()</div><div class="line">    if _,err := fileObj.WriteString(content);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful writing to the file with os.OpenFile and *File.WriteString method.&quot;,content)</div><div class="line">    &#125;</div><div class="line">    contents := []byte(content)</div><div class="line">    if _,err := fileObj.Write(contents);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful writing to thr file with os.OpenFile and *File.Write method.&quot;,content)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>注意:</code>使用<code>os.OpenFile(name string, flag int, perm FileMode)</code>打开文件并进行文件内容更改，需要注意<code>flag</code>相关的参数以及含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const (</div><div class="line">        O_RDONLY int = syscall.O_RDONLY // 只读打开文件和os.Open()同义</div><div class="line">        O_WRONLY int = syscall.O_WRONLY // 只写打开文件</div><div class="line">        O_RDWR   int = syscall.O_RDWR   // 读写方式打开文件</div><div class="line">        O_APPEND int = syscall.O_APPEND // 当写的时候使用追加模式到文件末尾</div><div class="line">        O_CREATE int = syscall.O_CREAT  // 如果文件不存在，此案创建</div><div class="line">        O_EXCL   int = syscall.O_EXCL   // 和O_CREATE一起使用, 只有当文件不存在时才创建</div><div class="line">        O_SYNC   int = syscall.O_SYNC   // 以同步I/O方式打开文件，直接写入硬盘.</div><div class="line">        O_TRUNC  int = syscall.O_TRUNC  // 如果可以的话，当打开文件时先清空文件</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="使用io包中的相关函数写入文件"><a href="#使用io包中的相关函数写入文件" class="headerlink" title="使用io包中的相关函数写入文件"></a>使用<code>io</code>包中的相关函数写入文件</h4><p>在<code>io</code>包中有一个<code>WriteString()</code>函数，用来将字符串写入一个<code>Writer</code>对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//将字符串s写入w(可以是一个[]byte)，如果w实现了一个WriteString方法，它可以被直接调用。否则w.Write会再一次被调用</div><div class="line">func WriteString(w Writer, s string) (n int, err error)</div><div class="line"></div><div class="line">//Writer对象的定义</div><div class="line">type Writer interface &#123;</div><div class="line">        Write(p []byte) (n int, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//使用io.WriteString()函数进行数据的写入</div><div class="line">func WriteWithIo(name,content string) &#123;</div><div class="line">    fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_APPEND,0644)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(&quot;Failed to open the file&quot;,err.Error())</div><div class="line">        os.Exit(2)</div><div class="line">    &#125;</div><div class="line">    if  _,err := io.WriteString(fileObj,content);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful appending to the file with os.OpenFile and io.WriteString.&quot;,content)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用bufio包中的相关函数写入文件"><a href="#使用bufio包中的相关函数写入文件" class="headerlink" title="使用bufio包中的相关函数写入文件"></a>使用<code>bufio</code>包中的相关函数写入文件</h4><p><code>bufio</code>和<code>io</code>包中很多操作都是相似的，唯一不同的地方是<code>bufio</code>提供了一些缓冲的操作，如果对文件I/O操作比较频繁的，使用<code>bufio</code>还是能增加一些性能的。</p>
<p>在<code>bufio</code>包中，有一个<code>Writer</code>结构体，而其相关的方法也支持一些写入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//Writer是一个空的结构体，一般需要使用NewWriter或者NewWriterSize来初始化一个结构体对象</div><div class="line">type Writer struct &#123;</div><div class="line">        // contains filtered or unexported fields</div><div class="line">&#125;</div><div class="line"></div><div class="line">//NewWriterSize和NewWriter函数</div><div class="line">//返回默认缓冲大小的Writer对象(默认是4096)</div><div class="line">func NewWriter(w io.Writer) *Writer</div><div class="line"></div><div class="line">//指定缓冲大小创建一个Writer对象</div><div class="line">func NewWriterSize(w io.Writer, size int) *Writer</div><div class="line"></div><div class="line">//Writer对象相关的写入数据的方法</div><div class="line"></div><div class="line">//把p中的内容写入buffer,返回写入的字节数和错误信息。如果nn&lt;len(p),返回错误信息中会包含为什么写入的数据比较短</div><div class="line">func (b *Writer) Write(p []byte) (nn int, err error)</div><div class="line">//将buffer中的数据写入 io.Writer</div><div class="line">func (b *Writer) Flush() error</div><div class="line"></div><div class="line">//以下三个方法可以直接写入到文件中</div><div class="line">//写入单个字节</div><div class="line">func (b *Writer) WriteByte(c byte) error</div><div class="line">//写入单个Unicode指针返回写入字节数错误信息</div><div class="line">func (b *Writer) WriteRune(r rune) (size int, err error)</div><div class="line">//写入字符串并返回写入字节数和错误信息</div><div class="line">func (b *Writer) WriteString(s string) (int, error)</div></pre></td></tr></table></figure></p>
<p><code>注意：如果需要再写入文件时利用缓冲的话只能使用bufio包中的Write方法</code></p>
<p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//使用bufio包中Writer对象的相关方法进行数据的写入</div><div class="line">func WriteWithBufio(name,content string) &#123;</div><div class="line">    if fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_APPEND,0644);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        writeObj := bufio.NewWriterSize(fileObj,4096)</div><div class="line">        //</div><div class="line">       if _,err := writeObj.WriteString(content);err == nil &#123;</div><div class="line">              fmt.Println(&quot;Successful appending buffer and flush to file with bufio&apos;s Writer obj WriteString method&quot;,content)</div><div class="line">           &#125;</div><div class="line"></div><div class="line">        //使用Write方法,需要使用Writer对象的Flush方法将buffer中的数据刷到磁盘</div><div class="line">        buf := []byte(content)</div><div class="line">        if _,err := writeObj.Write(buf);err == nil &#123;</div><div class="line">            fmt.Println(&quot;Successful appending to the buffer with os.OpenFile and bufio&apos;s Writer obj Write method.&quot;,content)</div><div class="line">            if  err := writeObj.Flush(); err != nil &#123;panic(err)&#125;</div><div class="line">            fmt.Println(&quot;Successful flush the buffer data to file &quot;,content)</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="写文件全部示例"><a href="#写文件全部示例" class="headerlink" title="写文件全部示例"></a>写文件全部示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @File Name: writefile.go</div><div class="line"> * @Author:</div><div class="line"> * @Email:</div><div class="line"> * @Create Date: 2017-12-17 12:12:09</div><div class="line"> * @Last Modified: 2017-12-17 23:12:10</div><div class="line"> * @Description:使用多种方式将数据写入文件</div><div class="line"> */</div><div class="line">package main</div><div class="line">import (</div><div class="line">    &quot;os&quot;</div><div class="line">    &quot;io&quot;</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;bufio&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">      name := &quot;testwritefile.txt&quot;</div><div class="line">      content := &quot;Hello, xxbandy.github.io!\n&quot;</div><div class="line">      WriteWithIoutil(name,content)</div><div class="line">      contents := &quot;Hello, xuxuebiao\n&quot;</div><div class="line">      //清空一次文件并写入两行contents</div><div class="line">      WriteWithFileWrite(name,contents)</div><div class="line">      WriteWithIo(name,content)</div><div class="line">      //使用bufio包需要将数据先读到buffer中，然后在flash到磁盘中</div><div class="line">      WriteWithBufio(name,contents)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用ioutil.WriteFile方式写入文件,是将[]byte内容写入文件,如果content字符串中没有换行符的话，默认就不会有换行符</div><div class="line">func WriteWithIoutil(name,content string) &#123;</div><div class="line">    data :=  []byte(content)</div><div class="line">    if ioutil.WriteFile(name,data,0644) == nil &#123;</div><div class="line">        fmt.Println(&quot;写入文件成功:&quot;,content)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//使用os.OpenFile()相关函数打开文件对象，并使用文件对象的相关方法进行文件写入操作</div><div class="line">//清空一次文件</div><div class="line">func WriteWithFileWrite(name,content string)&#123;</div><div class="line">    fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_TRUNC,0644)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(&quot;Failed to open the file&quot;,err.Error())</div><div class="line">        os.Exit(2)</div><div class="line">    &#125;</div><div class="line">    defer fileObj.Close()</div><div class="line">    if _,err := fileObj.WriteString(content);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful writing to the file with os.OpenFile and *File.WriteString method.&quot;,content)</div><div class="line">    &#125;</div><div class="line">    contents := []byte(content)</div><div class="line">    if _,err := fileObj.Write(contents);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful writing to thr file with os.OpenFile and *File.Write method.&quot;,content)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//使用io.WriteString()函数进行数据的写入</div><div class="line">func WriteWithIo(name,content string) &#123;</div><div class="line">    fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_APPEND,0644)</div><div class="line">    if err != nil &#123;</div><div class="line">        fmt.Println(&quot;Failed to open the file&quot;,err.Error())</div><div class="line">        os.Exit(2)</div><div class="line">    &#125;</div><div class="line">    if  _,err := io.WriteString(fileObj,content);err == nil &#123;</div><div class="line">        fmt.Println(&quot;Successful appending to the file with os.OpenFile and io.WriteString.&quot;,content)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用bufio包中Writer对象的相关方法进行数据的写入</div><div class="line">func WriteWithBufio(name,content string) &#123;</div><div class="line">    if fileObj,err := os.OpenFile(name,os.O_RDWR|os.O_CREATE|os.O_APPEND,0644);err == nil &#123;</div><div class="line">        defer fileObj.Close()</div><div class="line">        writeObj := bufio.NewWriterSize(fileObj,4096)</div><div class="line">        //</div><div class="line">       if _,err := writeObj.WriteString(content);err == nil &#123;</div><div class="line">              fmt.Println(&quot;Successful appending buffer and flush to file with bufio&apos;s Writer obj WriteString method&quot;,content)</div><div class="line">           &#125;</div><div class="line"></div><div class="line">        //使用Write方法,需要使用Writer对象的Flush方法将buffer中的数据刷到磁盘</div><div class="line">        buf := []byte(content)</div><div class="line">        if _,err := writeObj.Write(buf);err == nil &#123;</div><div class="line">            fmt.Println(&quot;Successful appending to the buffer with os.OpenFile and bufio&apos;s Writer obj Write method.&quot;,content)</div><div class="line">            if  err := writeObj.Flush(); err != nil &#123;panic(err)&#125;</div><div class="line">            fmt.Println(&quot;Successful flush the buffer data to file &quot;,content)</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用Golang进行文件读写的过程中，遇到几个细节问题导致程序写入数据时有一定脏数据的残留，最后发现是使用os.OpenFile在进行文件操作的时候没有使用正确的flag造成的。因此专门去学习了下Golang中读写文件的几种方式方法,在此记录下一些简单的操作，防止以后遗忘。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="I/O" scheme="http://yoursite.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>开源OCR引擎tesseract的构建使用</title>
    <link href="http://yoursite.com/2017/12/09/%E5%BC%80%E6%BA%90OCR%E5%BC%95%E6%93%8Etesseract%E7%9A%84%E6%9E%84%E5%BB%BA%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/12/09/开源OCR引擎tesseract的构建使用/</id>
    <published>2017-12-09T07:59:29.000Z</published>
    <updated>2017-12-10T13:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h4><p>光学字符识别(OCR,Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。OCR技术非常专业，一般多是印刷、打印行业的从业人员使用。而在人工智能快速发展阶段，该技术也被大量运用在一些常见的业务场景来提高业务流程效率，比如像一些文件扫描，身份证识别，图片识别等相关业务场景。</p>
<a id="more"></a>
<h4 id="tesseract"><a href="#tesseract" class="headerlink" title="tesseract"></a>tesseract</h4><p>Tesseract的OCR引擎最先由HP实验室于1985年开始研发，至1995年时已经成为OCR业内最准确的三款识别引擎之一。然而，HP不久便决定放弃OCR业务，Tesseract也从此尘封。<br>数年以后，HP意识到，与其将Tesseract束之高阁，不如贡献给开源软件业，让其重焕新生－－2005年，Tesseract由美国内华达州信息技术研究所获得，并求诸于Google对Tesseract进行改进、消除Bug、优化工作。</p>
<p><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="external">tesseract官方地址</a></p>
<p>需要注意的是，tesseract3.0以上才支持中文，而且从官方文档上看4.0版本（2017年1月左右发布）显著的提高了识别率，同时也加大了性能的消耗。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>一个亲身经历的场景就是以前去开户可能需要带上身份证资料各种去打印复印件进行物理备份，而使用OCR等相关人工智能技术后就可以通过手机摄像头快速识别身份证相关信息来存储个人资料，整个开户体验相当高效简单。</p>
<p>另外一个常见的场景可能就是我们手写的文章需要扫描成电子版，在以前我们可能需要专业的打印机设备才能够进行电子扫描，而当OCR相关技术普及到普通业务场景后，我们就可以使用手持设备进行纸质版的文件进行电子扫描。[个人之前尝试使用有道云笔记中的电子扫描功能还是相当不错的]</p>
<h3 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h3><p>tesseract需要<a href="http://www.leptonica.org/download.html" target="_blank" rel="external">Leptonica</a>的支持，leptonica是一个开源的面向教学的软件，通常被用来作为图像处理和图像分析的一个底层库支持。</p>
<h4 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h4><p>Centos7中的epel源中包含了tesseract的3.05版本的包，可以直接安装使用。而在tesseract的github官方项目中最新版本也只到<a href="https://github.com/tesseract-ocr/tesseract/releases" target="_blank" rel="external">3.05.01</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install epel-release</div><div class="line"> -y</div><div class="line"># 查看epel源</div><div class="line">$ cat /etc/yum.repos.d/epel.repo </div><div class="line">[epel]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch</div><div class="line">metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line"></div><div class="line">[epel-debuginfo]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Debug</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/$basearch/debug</div><div class="line">metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div><div class="line"></div><div class="line">[epel-source]</div><div class="line">name=Extra Packages for Enterprise Linux 7 - $basearch - Source</div><div class="line">#baseurl=http://download.fedoraproject.org/pub/epel/7/SRPMS</div><div class="line">metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearch</div><div class="line">failovermethod=priority</div><div class="line">enabled=0</div><div class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</div><div class="line">gpgcheck=1</div><div class="line"></div><div class="line"></div><div class="line"># 安装tesseract 以及相关的库依赖</div><div class="line">$ sudo yum install tesseract tesseract-devel -y </div><div class="line"></div><div class="line"># 安装中文库支持</div><div class="line">$ sudo yum install -y tesseract-langpack-chi_sim.noarch tesseract-langpack-chi_tra.noarch</div><div class="line"></div><div class="line"></div><div class="line"># 查看默认的配置以及语言库</div><div class="line">$ ls /usr/share/tesseract/tessdata</div><div class="line">chi_sim.traineddata  chi_tra.traineddata</div><div class="line"></div><div class="line"># 默认只支持eng英语一种语言，安装中文包之后查看语言支持</div><div class="line">$ tesseract --list-langs</div><div class="line">List of available languages (3):</div><div class="line">eng</div><div class="line">chi_sim</div><div class="line">chi_tra</div></pre></td></tr></table></figure>
<h4 id="2-源码编译最新版本-4-00-00alpha版本"><a href="#2-源码编译最新版本-4-00-00alpha版本" class="headerlink" title="2.源码编译最新版本(4.00.00alpha版本)"></a>2.源码编译最新版本(4.00.00alpha版本)</h4><p>从官网上看，4.0版本在识别率以及性能等各方面上要比3.0版本高好多，但是官方又没有提供4.0的release版本，因此接下来使用github上的源码来手动编译<a href="https://github.com/tesseract-ocr/tesseract/tree/4.00.00alpha" target="_blank" rel="external">tesseract4.00.00alpha</a>版本。同时由于对底层Leptonica的依赖，需要优先编译该库的依赖。</p>
<p><code>注意：宿主操作系统仍然是一个纯净的Centos7.3.1611的OS</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"># 安装基础依赖</div><div class="line"># sudo yum install gcc git gcc-c++ make automake libtool libpng-devel libjpeg-devel libtiff-devel zlib-devel -y</div><div class="line"></div><div class="line"># 安装leptonica-1.74.4</div><div class="line"># wget http://www.leptonica.org/source/leptonica-1.74.4.tar.gz  &amp;&amp; tar -zxf leptonica-1.74.4.tar.gz &amp;&amp; cd  leptonica ;./configure &amp;&amp; make &amp;&amp; make install</div><div class="line"></div><div class="line">........</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/lib&apos;</div><div class="line"> /bin/sh ../libtool   --mode=install /usr/bin/install -c   liblept.la &apos;/usr/local/lib&apos;</div><div class="line">libtool: install: /usr/bin/install -c .libs/liblept.so.5.0.1 /usr/local/lib/liblept.so.5.0.1</div><div class="line">libtool: install: (cd /usr/local/lib &amp;&amp; &#123; ln -s -f liblept.so.5.0.1 liblept.so.5 || &#123; rm -f liblept.so.5 &amp;&amp; ln -s liblept.so.5.0.1 liblept.so.5; &#125;; &#125;)</div><div class="line">libtool: install: (cd /usr/local/lib &amp;&amp; &#123; ln -s -f liblept.so.5.0.1 liblept.so || &#123; rm -f liblept.so &amp;&amp; ln -s liblept.so.5.0.1 liblept.so; &#125;; &#125;)</div><div class="line">libtool: install: /usr/bin/install -c .libs/liblept.lai /usr/local/lib/liblept.la</div><div class="line">libtool: install: /usr/bin/install -c .libs/liblept.a /usr/local/lib/liblept.a</div><div class="line">libtool: install: chmod 644 /usr/local/lib/liblept.a</div><div class="line">libtool: install: ranlib /usr/local/lib/liblept.a</div><div class="line">libtool: finish: PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin&quot; ldconfig -n /usr/local/lib</div><div class="line">----------------------------------------------------------------------</div><div class="line"></div><div class="line">Libraries have been installed in:</div><div class="line">   /usr/local/lib</div><div class="line"></div><div class="line">If you ever happen to want to link against installed libraries</div><div class="line">in a given directory, LIBDIR, you must either use libtool, and</div><div class="line">specify the full pathname of the library, or use the `-LLIBDIR&apos;</div><div class="line">flag during linking and do at least one of the following:</div><div class="line">   - add LIBDIR to the `LD_LIBRARY_PATH&apos; environment variable</div><div class="line">     during execution</div><div class="line">   - add LIBDIR to the `LD_RUN_PATH&apos; environment variable</div><div class="line">     during linking</div><div class="line">   - use the `-Wl,-rpath -Wl,LIBDIR&apos; linker flag</div><div class="line">   - have your system administrator add LIBDIR to `/etc/ld.so.conf&apos;</div><div class="line"></div><div class="line">See any operating system documentation about shared libraries for</div><div class="line">more information, such as the ld(1) and ld.so(8) manual pages.</div><div class="line">----------------------------------------------------------------------</div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/include/leptonica&apos;</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/bin&apos;</div><div class="line">  /bin/sh ../libtool   --mode=install /usr/bin/install -c convertfilestopdf convertfilestops convertformat convertsegfilestopdf convertsegfilestops converttopdf converttops fileinfo printimage printsplitimage printtiff splitimage2pdf xtractprotos &apos;/usr/local/bin&apos;</div><div class="line">......</div><div class="line"></div><div class="line">make[2]: Nothing to be done for `install-data-am&apos;.</div><div class="line">make[2]: Leaving directory `/export/servers/leptonica-1.74.4/prog&apos;</div><div class="line">make[1]: Leaving directory `/export/servers/leptonica-1.74.4/prog&apos;</div><div class="line">make[1]: Entering directory `/export/servers/leptonica-1.74.4&apos;</div><div class="line">make[2]: Entering directory `/export/servers/leptonica-1.74.4&apos;</div><div class="line">make[2]: Nothing to be done for `install-exec-am&apos;.</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/lib/pkgconfig&apos;</div><div class="line"> /usr/bin/install -c -m 644 lept.pc &apos;/usr/local/lib/pkgconfig&apos;</div><div class="line"></div><div class="line"># 以上输出显示leptonica已经成功编译，并给出相关提示知名动态链接库的地址以及头文件等相关地址，需要注意的在使用之前一定要加载动态链接库/usr/local/lib</div><div class="line"># ldconfig -n /usr/local/lib</div><div class="line"></div><div class="line"># 安装tesseract，由于作者在github上设置了tag来区分各个版本，因此我们需要切换到源码的指定分支进行源码编译</div><div class="line"># git clone https://github.com/tesseract-ocr/tesseract.git；</div><div class="line">cd tesseract &amp;&amp; git checkout -b biaoge 4.00.00alpha &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/include/tesseract</div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/lib&apos;</div><div class="line"></div><div class="line">libtool: finish: PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/sbin&quot; ldconfig -n /usr/local/lib</div><div class="line"></div><div class="line">----------------------------------------------------------------------</div><div class="line">Libraries have been installed in:</div><div class="line">   /usr/local/lib</div><div class="line"></div><div class="line">If you ever happen to want to link against installed libraries</div><div class="line">in a given directory, LIBDIR, you must either use libtool, and</div><div class="line">specify the full pathname of the library, or use the `-LLIBDIR&apos;</div><div class="line">flag during linking and do at least one of the following:</div><div class="line">   - add LIBDIR to the `LD_LIBRARY_PATH&apos; environment variable</div><div class="line">     during execution</div><div class="line">   - add LIBDIR to the `LD_RUN_PATH&apos; environment variable</div><div class="line">     during linking</div><div class="line">   - use the `-Wl,-rpath -Wl,LIBDIR&apos; linker flag</div><div class="line">   - have your system administrator add LIBDIR to `/etc/ld.so.conf&apos;</div><div class="line"></div><div class="line">See any operating system documentation about shared libraries for</div><div class="line">more information, such as the ld(1) and ld.so(8) manual pages.</div><div class="line">----------------------------------------------------------------------</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/bin&apos;</div><div class="line">  /bin/sh ../libtool   --mode=install /usr/bin/install -c tesseract &apos;/usr/local/bin&apos;</div><div class="line">libtool: install: /usr/bin/install -c .libs/tesseract /usr/local/bin/tesseract</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/include/tesseract&apos;</div><div class="line"> /usr/bin/install -c -m 644 apitypes.h baseapi.h capi.h renderer.h &apos;/usr/local/include/tesseract&apos;</div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/lib/pkgconfig&apos;</div><div class="line"> /usr/bin/install -c -m 644 tesseract.pc &apos;/usr/local/lib/pkgconfig&apos;</div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/share/tessdata/configs&apos;</div><div class="line"> /usr/bin/install -c -m 644 inter makebox box.train unlv ambigs.train api_config kannada box.train.stderr quiet logfile digits hocr tsv linebox pdf rebox strokewidth bigram txt &apos;/usr/local/share/tessdata/configs&apos;</div><div class="line"></div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/share/tessdata/tessconfigs&apos;</div><div class="line"> /usr/bin/install -c -m 644 batch batch.nochop nobatch matdemo segdemo msdemo &apos;/usr/local/share/tessdata/tessconfigs&apos;</div><div class="line"></div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/share/tessdata&apos;</div><div class="line"> /usr/bin/install -c -m 644 pdf.ttf &apos;/usr/local/share/tessdata&apos;</div><div class="line"></div><div class="line"></div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/share/man/man1&apos;</div><div class="line"> /usr/bin/install -c -m 644 cntraining.1 combine_tessdata.1 mftraining.1 tesseract.1 unicharset_extractor.1 wordlist2dawg.1 ambiguous_words.1 shapeclustering.1 dawg2wordlist.1 &apos;/usr/local/share/man/man1&apos;</div><div class="line"> /usr/bin/mkdir -p &apos;/usr/local/share/man/man5&apos;</div><div class="line"> /usr/bin/install -c -m 644 unicharambigs.5 unicharset.5 &apos;/usr/local/share/man/man5&apos;</div><div class="line"> </div><div class="line"># 以上输出也标明tesseract已经成功安装在了/usr/local/lib目录，并给出了一些tesseract相关的配置路径以及注意事项。特别需要注意的是，也需要加载动态链接库，否则程序可能无法识别相关的库文件。</div><div class="line"></div><div class="line"># ldconfig -n /usr/local/lib</div><div class="line"></div><div class="line"># 安装成功，即可使用tesseract命令(默认在/usr/local/bin/)</div><div class="line"># tesseract --version</div><div class="line">tesseract 4.00.00alpha</div><div class="line"> leptonica-1.74.4</div><div class="line"></div><div class="line"></div><div class="line"># 查看当前的语言库支持</div><div class="line"># tesseract --list-langs</div><div class="line">Error opening data file /usr/local/share/tessdata/eng.traineddata</div><div class="line">Please make sure the TESSDATA_PREFIX environment variable is set to the parent directory of your &quot;tessdata&quot; directory.</div><div class="line">Failed loading language &apos;eng&apos;</div><div class="line">Tesseract couldn&apos;t load any languages!</div><div class="line">Could not initialize tesseract.</div><div class="line"></div><div class="line"># 提示已经很明显，需要配置TESSDATA_PREFIX环境变量</div><div class="line"></div><div class="line"># 配置环境变量和相关的语言库</div><div class="line"># export TESSDATA_PREFIX=/usr/local/share/</div><div class="line"># cd $TESSDATA_PREFIX/tessdata </div><div class="line"># for font in chi_sim chi_tra eng ;do wget https://github.com/tesseract-ocr/tessdata/raw/master/$font.traineddata;done </div><div class="line"></div><div class="line"># 再次查看语言支持</div><div class="line"># tesseract --list-langs</div><div class="line">List of available languages (3):</div><div class="line">chi_sim</div><div class="line">eng</div><div class="line">chi_tra</div></pre></td></tr></table></figure>
<p>至此，环境中已经能够正常使用<code>tesseract</code>命令了，基本上可以认为tesseract环境已经编译完成，接下来就是具体看看如何去使用tesseract了</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><img src="https://img.alicdn.com/simba/img/TB1L8SKhwnH8KJjSspcSuv3QFXa.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ tesseract TB1L8SKhwnH8KJjSspcSuv3QFXa.jpg test -l chi_sim</div><div class="line">Tesseract Open Source OCR Engine v3.04.00 with Leptonica</div><div class="line"></div><div class="line"></div><div class="line">$ cat test.txt </div><div class="line">走心特惠</div><div class="line">不玩套路</div></pre></td></tr></table></figure></p>
<p>可以看出来对比较规范的字体还是可以正常识别的。</p>
<h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 测试使用</div><div class="line"># tesseract 5a0178d2N01754832.jpg test -l chi_sim </div><div class="line">Tesseract Open Source OCR Engine v4.00.00alpha with Leptonica</div><div class="line">pixReadStreamJpeg: function not present</div><div class="line">Error in fopenReadStream: file not found</div><div class="line">Error in findFileFormat: image file not found</div><div class="line">Error during processing.</div><div class="line"></div><div class="line"># 以上提示是因为Leptonica不支持某些图片格式</div><div class="line"># yum install ImageMagick -y </div><div class="line"># 重新编译Leptonica(增加--with-libpng参数)</div><div class="line"># cd /export/servers/leptonica-1.74 ;./configure --with-libpng &amp;&amp; make &amp;&amp; make install </div><div class="line"></div><div class="line"> </div><div class="line"># 再次测试</div><div class="line">$ tesseract TB1L8SKhwnH8KJjSspcSuv3QFXa.jpg test -l chi_sim</div><div class="line">Tesseract Open Source OCR Engine v3.04.00 with Leptonica</div><div class="line"></div><div class="line"></div><div class="line">$ cat test.txt </div><div class="line">走心特惠</div><div class="line">不玩套路</div></pre></td></tr></table></figure>
<h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>由于目前tesseract官方并未直接提供4.0的软件包，并且tesseract环境的构建也是稍微比较复杂，为了秉承造福群众的理念，我将以上环境封装成Docker image供各位网友使用。具体使用方式如下：</p>
<p><code>前提：需要有一个可用的Docker环境，任何版本都可以</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># 下载镜像(稍微有点大1.6G)</div><div class="line"># docker pull xxbandy123/tesseract-ocr4.00.00alpha:17-12-05</div><div class="line"></div><div class="line"># 运行tesseract环境</div><div class="line"># docker run -itd  xxbandy123/tesseract-ocr4.00.00alpha:17-12-05</div><div class="line">2b4df1a1e9d20426aefa32ba79066b561fe66c623986b76634012ac9cae40e64</div><div class="line"></div><div class="line"># 进入环境测试运行</div><div class="line"># docker exec -it $(docker ps -a -q -l) bash</div><div class="line">[root@2b4df1a1e9d2 /]# tesseract</div><div class="line">Usage:</div><div class="line">  tesseract --help | --help-psm | --version</div><div class="line">  tesseract --list-langs [--tessdata-dir PATH]</div><div class="line">  tesseract --print-parameters [options...] [configfile...]</div><div class="line">  tesseract imagename|stdin outputbase|stdout [options...] [configfile...]</div><div class="line">  </div><div class="line"># 测试环境运行</div><div class="line"># wget https://img.alicdn.com/tfs/TB16FK4SXXXXXXUXXXXXXXXXXXX-790-180.jpg</div><div class="line">[root@2b4df1a1e9d2 /]# tesseract TB16FK4SXXXXXXUXXXXXXXXXXXX-790-180.jpg test -l chi_sim</div><div class="line">Tesseract Open Source OCR Engine v4.00.00alpha with Leptonica</div><div class="line">[root@2b4df1a1e9d2 /]# cat test.txt</div><div class="line">一天猫电器全新服务保障</div><div class="line"></div><div class="line">胁 售后无忧</div></pre></td></tr></table></figure>
<p>测试原图<img src="https://img.alicdn.com/tfs/TB16FK4SXXXXXXUXXXXXXXXXXXX-790-180.jpg" alt=""></p>
<p>由此可见，开源的tesseract目前并不能完全识别所有的图片文字，如果需要借助于开源去做业务场景，可能还需要更多的二次改造才能够有所应用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id=&quot;OCR&quot;&gt;&lt;a href=&quot;#OCR&quot; class=&quot;headerlink&quot; title=&quot;OCR&quot;&gt;&lt;/a&gt;OCR&lt;/h4&gt;&lt;p&gt;光学字符识别(OCR,Optical Character Recognition)是指对文本资料进行扫描，然后对图像文件进行分析处理，获取文字及版面信息的过程。OCR技术非常专业，一般多是印刷、打印行业的从业人员使用。而在人工智能快速发展阶段，该技术也被大量运用在一些常见的业务场景来提高业务流程效率，比如像一些文件扫描，身份证识别，图片识别等相关业务场景。&lt;/p&gt;
    
    </summary>
    
      <category term="AI" scheme="http://yoursite.com/categories/AI/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="OCR" scheme="http://yoursite.com/tags/OCR/"/>
    
      <category term="Tesseract4.0" scheme="http://yoursite.com/tags/Tesseract4-0/"/>
    
  </entry>
  
  <entry>
    <title>效率工具技巧</title>
    <link href="http://yoursite.com/2017/11/28/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/11/28/效率工具技巧/</id>
    <published>2017-11-28T06:17:54.000Z</published>
    <updated>2018-01-18T14:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="Yaml语法检测"><a href="#Yaml语法检测" class="headerlink" title="Yaml语法检测"></a>Yaml语法检测</h3><p><a href="http://www.yamllint.com/" target="_blank" rel="external">yaml语法在线检测</a></p>
<h3 id="Json字符串解析"><a href="#Json字符串解析" class="headerlink" title="Json字符串解析"></a>Json字符串解析</h3><p><a href="http://www.kjson.com/" target="_blank" rel="external">json格式化在线校验工具</a></p>
<h3 id="Restful-API-文档-设计"><a href="#Restful-API-文档-设计" class="headerlink" title="Restful API 文档+设计"></a>Restful API 文档+设计</h3><p><a href="https://app.apiary.io" target="_blank" rel="external">在线api设计</a></p>
<h3 id="URL转PDF"><a href="#URL转PDF" class="headerlink" title="URL转PDF"></a>URL转PDF</h3><p><a href="http://pdfmyurl.com/" target="_blank" rel="external">在线URL转换PDF工具</a></p>
<p><a href="https://smallpdf.com/" target="_blank" rel="external">pdf在线转换工具</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Yaml语法检测&quot;&gt;&lt;a href=&quot;#Yaml语法检测&quot; class=&quot;headerlink&quot; title=&quot;Yaml语法检测&quot;&gt;&lt;/a&gt;Yaml语法检测&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.yamllint
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CPU虚拟化技术探究</title>
    <link href="http://yoursite.com/2017/11/09/KVM%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/11/09/KVM虚拟化技术探究/</id>
    <published>2017-11-09T13:57:45.000Z</published>
    <updated>2017-11-09T14:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>KVM虚拟机CPU的软件调优首先需要对NUMA技术有一定了解，调优的主要手段就是虚拟机对物理机CPU逻辑内核的手工绑定。<br>内存方面的调优手段主要是KSM，即相同内存页合并、内存气球技术以及大页内存的使用。</p>
<a id="more"></a>
<p><a href="http://blog.csdn.net/ustc_dylan/article/details/45667227" target="_blank" rel="external">NUMA架构理解</a></p>
<h3 id="NUMA技术与应用"><a href="#NUMA技术与应用" class="headerlink" title="NUMA技术与应用"></a>NUMA技术与应用</h3><p><strong>多CPU共同工作技术的架构：SMP,MPP,NUMA</strong></p>
<p>1.1 SMP技术：<br>多个cpu通过一个总线访问存储器，因此SMP系统有时也被称为一致性内存访问(UMA)结构体系。一致性指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值。(多个cpu通过总线访问共同的内存)。缺点是扩展性有限，存储器接口达到饱和的时候，增加处理器不能获得更高的性能，因此SMP方式支持的CPU个数有限啊</p>
<p>1.2 MPP模式：<br>一种分布式存储器模式，能够将更多的处理器纳入一个系统的存储器,一个分布式存储器模式具有多个节点，每个节点都有自己的存储器，可以配置为SMP模式。单个节点相互连接起来形成一个总系统。MPP可以近似理解成一个SMP的横向扩展集群。MPP一般依靠软件实现。</p>
<p>1.3 NUMA技术：<br>每个处理器都有自己的存储器，每个处理器也可以访问别的处理器的存储器。<br>多核NUMA CPU架构：<br>NUMA node1:                        NUMA node2:<br>Core1 Core2                        Core1 Core2<br>   CPU0                                  CPU1<br>Core3 Core4                     Core3 Core4</p>
<p>查看cpu详情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># lscpu</div><div class="line">Architecture:          x86_64</div><div class="line">CPU op-mode(s):        32-bit, 64-bit</div><div class="line">Byte Order:            Little Endian</div><div class="line">CPU(s):                32                   //共有32个逻辑CPU（threads）</div><div class="line">On-line CPU(s) list:   0-31</div><div class="line">Thread(s) per core:    2                    //每个core有2个threads</div><div class="line">Core(s) per socket:    8                    //每个socket有8个cores</div><div class="line">Socket(s):             2                    //共有2个sockets</div><div class="line">NUMA node(s):          2                    //共有2个NUMA nodes</div><div class="line">Vendor ID:             GenuineIntel</div><div class="line">CPU family:            6</div><div class="line">Model:                 63</div><div class="line">Stepping:              2</div><div class="line">CPU MHz:               2600.014</div><div class="line">BogoMIPS:              5199.25</div><div class="line">Virtualization:        VT-x</div><div class="line">L1d cache:             32K</div><div class="line">L1i cache:             32K</div><div class="line">L2 cache:              256K</div><div class="line">L3 cache:              20480K</div><div class="line">NUMA node0 CPU(s):     0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30</div><div class="line">NUMA node1 CPU(s):     1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31</div><div class="line"></div><div class="line"># 2(node/socket)*8(8cores/socket)*2(2threads/core)</div><div class="line">2 Sockets 2 CPUs ,1Socket 1 numa node,1 numa node 8 cores,1 core 2 threads</div></pre></td></tr></table></figure></p>
<h3 id="KVM虚拟机NUMA调优"><a href="#KVM虚拟机NUMA调优" class="headerlink" title="KVM虚拟机NUMA调优"></a>KVM虚拟机NUMA调优</h3><h4 id="宿主机的NUMA信息查看和配置："><a href="#宿主机的NUMA信息查看和配置：" class="headerlink" title="宿主机的NUMA信息查看和配置："></a>宿主机的NUMA信息查看和配置：</h4><p>因为NUMA架构每个处理器都可以访问自己和别的处理器的存储器，访问自己的存储器要比访问别的存储器快很多，相差10~100倍，所以NUMA调优的目标就是让处理器尽量访问自己的存储器。<br><img src="http://oyep1jupk.bkt.clouddn.com/kvm/cpu/CPU-numa.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"># sh getcpuinfo.sh</div><div class="line">===== CPU Topology Table =====</div><div class="line"></div><div class="line">+--------------+---------+-----------+</div><div class="line">| Processor ID | Core ID | Socket ID |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 0            | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 1            | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 2            | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 3            | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 4            | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 5            | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 6            | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 7            | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 8            | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 9            | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 10           | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 11           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 12           | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 13           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 14           | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 15           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 16           | 0       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 17           | 0       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 18           | 1       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 19           | 1       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 20           | 2       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 21           | 2       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 22           | 3       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 23           | 3       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 24           | 4       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 25           | 4       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 26           | 5       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 27           | 5       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 28           | 6       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 29           | 6       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 30           | 7       | 0         |</div><div class="line">+--------------+---------+-----------+</div><div class="line">| 31           | 7       | 1         |</div><div class="line">+--------------+---------+-----------+</div><div class="line"></div><div class="line">Socket 0: 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30</div><div class="line">Socket 1: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31</div><div class="line"></div><div class="line">===== CPU Info Summary =====</div><div class="line"></div><div class="line">Logical processors: 32</div><div class="line">Physical socket: 2</div><div class="line">Siblings in one socket:  16</div><div class="line">Cores in one socket:  8</div><div class="line">Cores in total: 16</div><div class="line">Hyper-Threading: on</div><div class="line"></div><div class="line">===== END =====</div></pre></td></tr></table></figure>
<p>查看numa架构模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># cat /sys/bus/pci/devices/0000\:07\:00.0/numa_node</div><div class="line">0</div><div class="line"></div><div class="line">使用numactl --hardware查看当前CPU硬件的情况：</div><div class="line"></div><div class="line">由以下信息可以看到，当前CPU有两颗，每颗CPU8核，每颗CPU有64G内存可以使用</div><div class="line"># numactl --hardware</div><div class="line">available: 2 nodes (0-1)</div><div class="line">node 0 cpus: 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30</div><div class="line">node 0 size: 65490 MB</div><div class="line">node 0 free: 501 MB</div><div class="line">node 1 cpus: 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31</div><div class="line">node 1 size: 65536 MB</div><div class="line">node 1 free: 185 MB</div><div class="line">node distances:</div><div class="line">node   0   1</div><div class="line">  0:  10  20</div><div class="line">  1:  20  10</div></pre></td></tr></table></figure></p>
<p>查看每个node的内存情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">使用numastat命令可以查看每个节点的内存情况：</div><div class="line"># numastat</div><div class="line">                           node0           node1</div><div class="line">numa_hit             11541910709      7342897046		#使用本节点内存次数</div><div class="line">numa_miss               10973455        14712396		#计划使用本节点而被调度到其他节点次数</div><div class="line">numa_foreign            14712396        10973455		#计划使用其他节点内存而被使用本地内存次数</div><div class="line">interleave_hit             32651           32580		#交叉分配使用的内存中使用本节点的内存次数</div><div class="line">local_node           11540101051      7342503537		#在本节点运行的程序使用本节点内存的次数</div><div class="line">other_node              12783113        15105905		#在其他节点运行的程序使用本节点内存次数</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">使用numastat -c 查看相关进程的NUMA内存使用情况：</div><div class="line"># numastat -c qemu-kvm</div><div class="line"></div><div class="line">Per-node process memory usage (in MBs)</div><div class="line">PID              Node 0 Node 1  Total</div><div class="line">---------------  ------ ------ ------</div><div class="line">27822 (qemu-kvm)   5786   2449   8236</div><div class="line">27947 (qemu-kvm)   5503   2729   8232</div><div class="line">28108 (qemu-kvm)   4154   4116   8269</div><div class="line">28295 (qemu-kvm)   5845   2410   8255</div><div class="line">32840 (qemu-kvm)   5652   2749   8401</div><div class="line">32994 (qemu-kvm)   6229   2095   8324</div><div class="line">33235 (qemu-kvm)   3086   5287   8373</div><div class="line">33453 (qemu-kvm)   3577   4817   8394</div><div class="line">33620 (qemu-kvm)   5112   3326   8438</div><div class="line">33893 (qemu-kvm)   5529   2863   8391</div><div class="line">34141 (qemu-kvm)   4745   3689   8434</div><div class="line">34318 (qemu-kvm)   2414   5989   8404</div><div class="line">---------------  ------ ------ ------</div><div class="line">Total             57632  42519 100151</div><div class="line"></div><div class="line">Liunx系统默认是自动NUMA平衡策略，如果需要关闭Linux系统的自动平衡，可以使用如下命令：</div><div class="line">echo 0 &gt; /proc/sys/kernel/numa_balancing</div></pre></td></tr></table></figure></p>
<h4 id="虚拟机NUMA信息查看与配置"><a href="#虚拟机NUMA信息查看与配置" class="headerlink" title="虚拟机NUMA信息查看与配置"></a>虚拟机NUMA信息查看与配置</h4><p>查看虚拟机VCPU和物理CPU的对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"># virsh vcpuinfo xxbandy.github.io</div><div class="line">VCPU:           0</div><div class="line">CPU:            12</div><div class="line">State:          running</div><div class="line">CPU time:       466238.9s</div><div class="line">CPU Affinity:   yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</div><div class="line"></div><div class="line">VCPU:           1</div><div class="line">CPU:            5</div><div class="line">State:          running</div><div class="line">CPU time:       387815.5s</div><div class="line">CPU Affinity:   yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</div><div class="line"></div><div class="line">VCPU:           2</div><div class="line">CPU:            4</div><div class="line">State:          running</div><div class="line">CPU time:       397013.3s</div><div class="line">CPU Affinity:   yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</div><div class="line"></div><div class="line">VCPU:           3</div><div class="line">CPU:            31</div><div class="line">State:          running</div><div class="line">CPU time:       389255.3s</div><div class="line">CPU Affinity:   yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</div><div class="line">最后一行CPU亲和性：</div></pre></td></tr></table></figure>
<h4 id="透明大页技术与应用"><a href="#透明大页技术与应用" class="headerlink" title="透明大页技术与应用"></a>透明大页技术与应用</h4><p>X86默认的内存页大小是4KB，也可以使用2MB或者1GB的巨型页，系统的巨型页可以传输过虚拟机，kvm虚拟机可以通过分配巨型页提高性能。<br>使用巨型页可以提高内存的分配效率，提升系统性能。</p>
<p>使用透明大页的好处：<br>    可以使用swap，内存页默认2MB，需要使用swap的时候，内存被分割为4KB。<br>    对用户透明，不需要用户做特殊配置。<br>    不需要root权限<br>    不需要依赖某种库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">透明大页内存配置：</div><div class="line"># cat /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line">[always] madvise never</div><div class="line">修改配置：</div><div class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</div><div class="line">参数说明：</div><div class="line">	never：关闭，不使用透明内存</div><div class="line">	alway:尽量使用透明内存，扫描内存，有512个4KB页面可以整合，就整合成一个2MB的页面。</div><div class="line">	madvise:避免改变内存占用</div><div class="line"></div><div class="line">使用情况监控：</div><div class="line">$ cat /sys/kernel/mm/transparent_hugepage/khugepaged/pages_to_scan 默认(4096=16MB)一个扫描周期被扫描的内存页数</div><div class="line">4096</div><div class="line">$ cat /sys/kernel/mm/transparent_hugepage/khugepaged/scan_sleep_millisecs 默认(10000=10s)多长时间扫描一次</div><div class="line">10000</div><div class="line">$ cat /sys/kernel/mm/transparent_hugepage/khugepaged/alloc_sleep_millisecs 默认(60000=60s)多长时间整理一次碎片</div><div class="line">60000</div><div class="line">也可以查看meminfo信息；查看当前的巨型页值：</div><div class="line">$ grep Huge /proc/meminfo</div><div class="line">AnonHugePages:  102537216 kB</div><div class="line">HugePages_Total:       0</div><div class="line">HugePages_Free:        0</div><div class="line">HugePages_Rsvd:        0</div><div class="line">HugePages_Surp:        0</div><div class="line">Hugepagesize:       2048 kB</div><div class="line"></div><div class="line">查看当前巨型页使用情况</div><div class="line">$ cat /proc/sys/vm/nr_hugepages</div><div class="line">0</div><div class="line">巨型页默认大小是2MB，可以修改使用的巨型页数量：</div><div class="line">echo 25000 &gt; /proc/sys/vm/nr_hugepages</div><div class="line">或者：</div><div class="line">sysctl vm.nr_hugepages = N</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KVM虚拟机CPU的软件调优首先需要对NUMA技术有一定了解，调优的主要手段就是虚拟机对物理机CPU逻辑内核的手工绑定。&lt;br&gt;内存方面的调优手段主要是KSM，即相同内存页合并、内存气球技术以及大页内存的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://yoursite.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="KVM" scheme="http://yoursite.com/tags/KVM/"/>
    
      <category term="CPU架构" scheme="http://yoursite.com/tags/CPU%E6%9E%B6%E6%9E%84/"/>
    
      <category term="NUMA" scheme="http://yoursite.com/tags/NUMA/"/>
    
  </entry>
  
  <entry>
    <title>如何更加优雅的使用Docker</title>
    <link href="http://yoursite.com/2017/11/09/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%8A%A0%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Docker/"/>
    <id>http://yoursite.com/2017/11/09/如何更加优雅的使用Docker/</id>
    <published>2017-11-09T13:45:25.000Z</published>
    <updated>2017-12-10T13:12:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在使用docker过程中，我们经常发现管理维护是一个很复杂过程，因为我们在使用docker commands的过程中，我们只会去使用我们认为简单并且熟悉的命令，然而docker本身其实是提供给我们很多便捷且人性化的工具的，如果掌握这些使用技巧，也许你的维护管理工作将会事半功倍，并且给人看起来会很牛逼的样子。</p>
</blockquote>
<a id="more"></a>
<h3 id="创建容器时传入环境变量"><a href="#创建容器时传入环境变量" class="headerlink" title="创建容器时传入环境变量"></a>创建容器时传入环境变量</h3><p>在实际应用场景中，不论是从安全还是可配置方面去考虑，很多参数是比较适合用环境变量加载进去的，比如数据库的连接信息，时区，还有字体支持等等，在创建容器的时候其实都可以使用-e 指定key/value进行传递环境变量进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; 172.25.46.9:5001/centos6.8-jdjr-test-app </div><div class="line">ee20b44301e27c16eae63dab243d293054178dd5f819c23d44bd9e534208bb42</div><div class="line">sh-4.2# docker exec -it test-env date</div><div class="line">2017年 01月 17日 星期二 10:35:17 CST</div><div class="line">sh-4.2# date</div><div class="line">Tue Jan 17 10:35:21 CST 2017</div><div class="line">可以看到加了时区环境变量的容器已经和宿主机在同一个时区(CST)，并且时间和宿主机基本同步</div><div class="line"></div><div class="line">sh-4.2# docker run -itd --name test  172.25.46.9:5001/centos6.8-jdjr-test-app</div><div class="line">d6a02874b999ff4eea79e3b302148b42043af01c89a5d31e5d858e0806f9077a</div><div class="line">sh-4.2# docker exec -it test date</div><div class="line">2017年 01月 20日 星期五 01:43:48 Asia</div><div class="line">默认没有加时区环境变量的容器还是Asia</div></pre></td></tr></table></figure>
<h3 id="调整宿主机和容器的时间差异"><a href="#调整宿主机和容器的时间差异" class="headerlink" title="调整宿主机和容器的时间差异"></a>调整宿主机和容器的时间差异</h3><p>首先我们需要弄清几个概念：在类unix系统中有硬件时钟与系统时钟，硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟，系统时钟则是指kernel中的时钟。unix以及linux系统时间是从格林威治时间到当前的秒数，即1970年1月1日凌晨零点零分零秒到当前的时间，全球都一样，这是绝对值；而时区则是由于地理位置差异、行政区划导致各地显示时间的差异，为了克服时间上的混乱，规定将全球划分为24个时区，我们国家属于东八区标识为CST。</p>
<p>因此，对于 Docker 容器而言，根本不存在宿主和容器的时间差异问题，因为他们使用的是同一个内核、同一个时钟，二者完全一样，所以根本不存在同步问题。一般来说这个问题是由时区导致的，可以使用date命令查看下容器当前的时间时区是啥。UTC(通用协调时)表示使用的是国际标准0时区，UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。CST表示中国标准时间时区一般是中国上海”Aisa/Shanghai”，也就是说UTC和CST相差了8个小时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">解决办法：</div><div class="line">创建容器的时候，使用-e 将时区信息传入到容器内部。</div><div class="line">sh-4.2# docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; images</div></pre></td></tr></table></figure>
<p><code>注意：其实使用单纯的环境变量来改变容器内部的TIME ZONE，只会影响当前容器用户的时区，一旦切换到真正的root用户就会发现时区依然是不正确的，比如以下栗子：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; images</div><div class="line">$ docker exec -it test-env bash</div><div class="line">bash-4.1# date</div><div class="line">2017年 09月 20日 星期三 20:45:54 CST</div><div class="line">bash-4.1# sudo su -c date</div><div class="line">2017年 09月 20日 星期三 08:46:02 EDT</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<p>那么如何真正解决时区这个问题呢？其实是<code>/etc/localtime</code>在作怪，用户只需要将容器内部的localtime改成你想要的时区就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bash-4.1# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </div><div class="line">bash-4.1# date</div><div class="line">2017年 09月 20日 星期三 20:54:35 CST</div><div class="line">bash-4.1# sudo su -c date</div><div class="line">2017年 09月 20日 星期三 20:54:39 CST</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<p>So,在使用Dockerfile构建镜像的时候将<code>/usr/share/zoneinfo/Asia/Shanghai</code>强制软连接到<code>/etc/localtime</code>就可以永久修复时区的问题了。</p>
<p>####指定容器的rootfs的大小<br>在使用docker的过程中，会发现cpu和memory可以很随意的动态调整，但是默认的rootfs却是不能随意调整的，默认是10g大小，当然如果对于数据有需求，可以通过挂载voulme进行扩展存储。如果用户执意想要调整rootfs的大小，在docker1.12版本默认提供了两种方式：在启动docker 的时候加载参数<code>--storage-opt dm.basesize=40G</code>用来调整默认容器的rootfs大小；在创建容器的时候使用参数<code>--storage-opt size=70G</code>来设置改容器的rootfs大小。</p>
<p><code>喜讯：在docker最近发布的1.13版本中，支持了磁盘的配额，不过还未测试</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name volume-test --storage-opt size=70G 172.25.46.9:5001/centos6.8-jdjr-test-app</div><div class="line">18d47e69802aa84df00182885b256c50ebc56e15d8e6990fc1e187ffe254171e</div><div class="line"></div><div class="line">sh-4.2# docker exec -it volume-test df -H | grep rootfs</div><div class="line">rootfs                 76G  1.5G   74G   2% /</div><div class="line">sh-4.2# docker exec -it test-env df -H | grep rootfs</div><div class="line">rootfs                 11G  1.5G  9.3G  14% /</div></pre></td></tr></table></figure>
<h4 id="快速管理容器和镜像"><a href="#快速管理容器和镜像" class="headerlink" title="快速管理容器和镜像"></a>快速管理容器和镜像</h4><p>在docker中删除容器需要指定容器名或者容器id，但是在容器比较多，并且状态不一的情况下删除容器还是需要走下心的。不过好处是docker ps默认提供了很多好用的功能，可以很方便地管理容器(创建容器的时候如果加上label后更方便哦)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">原理：先用docker ps -a -q 输出所有容器的container id(-f 表示过滤参数或者输出格式)，然后作为docker rm 的参数进行批量删除</div><div class="line">输出所有容器的name：</div><div class="line">sh-4.2# docker ps --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">test-env</div><div class="line">test-args</div><div class="line">test-run</div><div class="line">输出所有容器名包含test的容器，并打印容器名</div><div class="line">sh-4.2# docker ps -f name=test --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">test-env</div><div class="line">test-args</div><div class="line">test-run</div><div class="line">查看退出状态的容器，并打印容器名</div><div class="line">sh-4.2# docker ps -f status=exited --format=&quot;&#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">thirsty_brahmagupta</div><div class="line">clever_mestorf</div><div class="line">hopeful_morse</div><div class="line">stoic_morse</div><div class="line">elated_williams</div><div class="line">tender_jepsen</div><div class="line">reverent_mirzakhani</div><div class="line"></div><div class="line">删除所有容器：</div><div class="line">sh-4.2# docker rm -f -v $(docker ps -a -q)</div><div class="line">删除/启动所有退出的容器：</div><div class="line">sh-4.2# docker rm/start $(docker ps -qf status=exited)</div><div class="line">删除所有镜像：</div><div class="line">sh-4.2# docker rmi $(docker images -q)</div><div class="line"></div><div class="line">查看悬挂镜像:</div><div class="line">sh-4.1# docker  images -qf dangling=true</div><div class="line"></div><div class="line">只查看镜像或者容器指定的信息(在docker1.10之后才支持的)</div><div class="line"></div><div class="line">只列出镜像的id以及仓库名称：</div><div class="line">sh-4.2# docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</div><div class="line">67591570dd29: centos</div><div class="line">0a18f1c0ead2: rancher/server</div><div class="line"></div><div class="line">只列出容器的相关id,image,status和name</div><div class="line">sh-4.2# docker ps --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Image&#125;&#125; : &#123;&#123;.Status&#125;&#125; : &#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">66b60b72f00e: centos : Up 7 days : pensive_poincare</div><div class="line">或者自己重新定义列,就和原生差不多:</div><div class="line">sh-4.2# docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">CONTAINER ID        IMAGE                                         STATUS              NAMES</div><div class="line">66b60b72f00e        centos                                        Up 7 days           pensive_poincare</div></pre></td></tr></table></figure>
<p><code>注意:</code>其实上面的–format利用的就是go语言中的模版语法，所有容器的组织信息都在结构体中：</p>
<p><code>*formatter.containerContext</code></p>
<h4 id="容器label的使用"><a href="#容器label的使用" class="headerlink" title="容器label的使用"></a>容器label的使用</h4><p>在实际运维过程中，大量的容器可能会一些运维上的挑战，通过使用label，可以很好的将容器分类。label贯穿于docker的整个过程。<br>这个label可以作为你区分业务，区分模板各种区分容器的标识，通过标识，可以将容器更好的进行分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name volume-test --storage-opt size=70G --label zone=test 172.25.46.9:5001/centos6.8-jdjr-test-app</div><div class="line">c3772397e58e663095c2c0fd8d688b3d41b494097999ec2b6d6b7c509d23a138</div><div class="line">创建容器的时候定义一个label，表示该容器在test这个区域</div><div class="line">使用定义的label进行快速检索容器，并进行下一步操作(比如删除啦，更新啦)</div><div class="line">sh-4.2# docker ps -qf label=zone=test</div><div class="line">c3772397e58e</div><div class="line">sh-4.2# docker ps -f label=zone=test --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">volume-test</div></pre></td></tr></table></figure>
<h4 id="快速查看容器的相关配置信息"><a href="#快速查看容器的相关配置信息" class="headerlink" title="快速查看容器的相关配置信息"></a>快速查看容器的相关配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">查看容器的devicemapper设备：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.GraphDriver.Data.DeviceName&#125;&#125;&apos; nginx </div><div class="line">docker-8:1-67411759-7c9d6d3327b02659c81bcb70bf6a4c7a45df6a589af2a2d42a387dc0e90d4913</div><div class="line">查看容器的PID：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.State.Pid&#125;&#125;&apos; nginx </div><div class="line">27521</div><div class="line">查看容器name：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.Name&#125;&#125;&apos; nginx </div><div class="line">/nginx</div><div class="line">获取容器的ID：</div><div class="line">sh-4.2# docker inspect --format &#123;&#123;.Id&#125;&#125; nginx</div><div class="line">53214bc9cd001f2c548edcce0c42fe51f1a118c08941406d43122a8348055843</div></pre></td></tr></table></figure>
<h4 id="使用alias来预定义常用的命令"><a href="#使用alias来预定义常用的命令" class="headerlink" title="使用alias来预定义常用的命令"></a>使用alias来预定义常用的命令</h4><p>docker管理命令经常需要指定各种参数，通过linux的alias命令将默认的参数预定义起来，可以很方便的进行管理容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sh-4.2# alias dockerrm=&apos;docker rm -f -v&apos;</div><div class="line">sh-4.2# alias dockerexec=&apos;docker exec -it&apos;</div><div class="line">sh-4.2# alias dockerrmimage=&apos;docker rmi&apos;</div><div class="line"></div><div class="line">sh-4.2# dockerrm volume-test</div><div class="line">volume-test</div><div class="line"></div><div class="line">sh-4.2# dockerexec volume-test ls</div><div class="line">bin   dev  export  lib	  media  opt   root  selinux  sys  usr</div><div class="line">boot  etc  home    lib64  mnt	 proc  sbin  srv      tmp  var</div><div class="line">sh-4.2# dockerexec volume-test bash</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<h4 id="使容器随着docker-daemon的启动一同启动"><a href="#使容器随着docker-daemon的启动一同启动" class="headerlink" title="使容器随着docker daemon的启动一同启动"></a>使容器随着docker daemon的启动一同启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run 的时候加参数--restart=always</div></pre></td></tr></table></figure>
<h4 id="如何动态修改容器的内存和cpu限制docker1-10之后才支持的动态调整"><a href="#如何动态修改容器的内存和cpu限制docker1-10之后才支持的动态调整" class="headerlink" title="如何动态修改容器的内存和cpu限制docker1.10之后才支持的动态调整"></a>如何动态修改容器的内存和cpu限制<code>docker1.10之后才支持的动态调整</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sh-4.2# dockerexec test-env cat /sys/fs/cgroup/memory/memory.limit_in_bytes</div><div class="line">9223372036854775807</div><div class="line">sh-4.2# cat /sys/fs/cgroup/memory/memory.limit_in_bytes </div><div class="line">9223372036854775807</div><div class="line">可以看到，默认没有给容器限制内存，它会共享宿主机的所有内存</div><div class="line">动态调整内存为2014M：</div><div class="line">sh-4.2# docker update -m 2014M test-env</div><div class="line">test-env</div><div class="line">sh-4.2# dockerexec test-env cat /sys/fs/cgroup/memory/memory.limit_in_bytes</div><div class="line">2111832064</div></pre></td></tr></table></figure>
<h4 id="docker容器中真实用户的隔离"><a href="#docker容器中真实用户的隔离" class="headerlink" title="docker容器中真实用户的隔离"></a>docker容器中真实用户的隔离</h4><p>注意：默认docker容器内部的用户会继承宿主机的用户id，也就是说容器外部有一个uid为500的用户test，容器内部有一个uid为500的用户admin，容器内部运行的程序如果在宿主机上查看的时候会发现程序的启动用户会是外部宿主机的test用户。<br>这是因为默认情况下容器的 user namespace 并未开启，所以容器内的用户和宿主用户共享 uid 空间。容器内的 uid 为 0 的 root，就被系统视为 uid=0 的宿主 root，因此磁盘读写时，具有宿主 root 同等读写权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开启user namespace：</div><div class="line">启动docker的时候加参数--userns-remap=default</div><div class="line">https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options</div></pre></td></tr></table></figure></p>
<h4 id="在docker-container和物理机中双向拷贝文件"><a href="#在docker-container和物理机中双向拷贝文件" class="headerlink" title="在docker container和物理机中双向拷贝文件"></a>在docker container和物理机中双向拷贝文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">容器内部文件拷贝到宿主机：</div><div class="line">sh-4.2# docker cp jupyter-70002111:/home/70002111/教程-研究功能介绍.ipynb .</div><div class="line">sh-4.2# ls</div><div class="line">Dockerfile  教程-研究功能介绍.ipynb</div><div class="line">宿主机文件拷贝到容器：</div><div class="line">sh-4.2# docker cp Dockerfile jupyter-70002111:/home/70002111/</div><div class="line">sh-4.2# docker exec -it jupyter-70002188 ls </div><div class="line">Dockerfile</div></pre></td></tr></table></figure>
<h4 id="向容器内部程序发送signal"><a href="#向容器内部程序发送signal" class="headerlink" title="向容器内部程序发送signal"></a>向容器内部程序发送signal</h4><p>注意：在给容器进程发送SIGTERM信号时只会发给主进程，也就是容器内 PID 为 1 的进程。至于说主进程启动的那些子进程，完全看主进程是否愿意转发SIGTERM 给子进程了。所以那些把 Docker当做虚拟机用的，主进程跑了个bash，然后exec 进去启动程序的，或者来个&amp;让程序跑后台的情况，应用进程必然无法收到SIGTERM。<br><br>还有一种可能是在Dockerfile中的CMD那行用的是 shell 格式写的命令，而不是 exec 格式。在镜像中使用CMD启动的容器会加一个 sh -c 来去执行，因此使用 shell 格式写 CMD 的时候，PID 为 1 的进程是 sh，而它不转发信号，所以主程序收不到。</p>
<p>所以在写CMD哪行命令的时候，最好按照exec格式去写。</p>
<p><code>划重点: 由于在容器内部是没有init进程的，所以容器的整个生命周期会和容器内部PID为1的进程紧密相连，用户在使用过程中经常会发现容器更新版本之后，业务调用方经常会有一些请求异常，这其实也是因为容器内部的1号进程的设置有关，导致容器在停止时可能直接发送SIGKILL信号，导致容器当前正在处理中的业务也会立即断开连接，这样可能会导致一些业务异常</code></p>
<p>总而言之，向容器内部程序发送合适的信号是非常有必要的，这样可以使你的容器很优雅的退出。<code>docker stop操作会让容器在10s后进行优雅的退出</code></p>
<p><a href="https://segmentfault.com/a/1190000008233992" target="_blank" rel="external">如何优雅的关闭容器</a></p>
<h4 id="容器的cache不释放"><a href="#容器的cache不释放" class="headerlink" title="容器的cache不释放"></a>容器的cache不释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo 1 &gt; /proc/sys/vm/drop_caches</div></pre></td></tr></table></figure>
<h4 id="桥接网络连入下层网络并使用IPAM-没有NAT-端口映射"><a href="#桥接网络连入下层网络并使用IPAM-没有NAT-端口映射" class="headerlink" title="桥接网络连入下层网络并使用IPAM (没有NAT/端口映射)"></a>桥接网络连入下层网络并使用IPAM (没有NAT/端口映射)</h4><p><code>注意:docker network是1.12版本加进来的，支持了多种网络插件</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ docker network create \</div><div class="line">	-d bridge \</div><div class="line">	--subnet=192.168.57.0/24 \</div><div class="line">	--ip-range=192.168.57.32/28 \</div><div class="line">	--gateway=192.168.57.11 \</div><div class="line">	--aux-address DefaultGatewayIPv4=192.168.57.1 \</div><div class="line">	-o com.docker.network.bridge.name=brnet \</div><div class="line">	brnet</div><div class="line">$ brctl addif brnet eth2</div><div class="line">$ docker run --net=brnet -it busybox ifconfig</div><div class="line"></div><div class="line">注意其它主机的 --ip-range 和 --gateway 需要做对应调整。</div><div class="line"></div><div class="line">这种拓扑是，容器内 eth0 连接 brnet 接口，该接口直接通过 eth2 访问交换。</div></pre></td></tr></table></figure>
<h4 id="Docker查看某个容器绑定的cpu内核"><a href="#Docker查看某个容器绑定的cpu内核" class="headerlink" title="Docker查看某个容器绑定的cpu内核"></a>Docker查看某个容器绑定的cpu内核</h4><p><code>容器内部第一个进程编号一般为1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker exec -it container-name taskset -c -p 1 </div><div class="line">pid 1&apos;s current affinity list:0-3</div></pre></td></tr></table></figure>
<h4 id="给docker配置hosts"><a href="#给docker配置hosts" class="headerlink" title="给docker配置hosts"></a>给docker配置hosts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker run --add-host biaoge-ops:192.168.0.1 centos cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">::1	localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0	ip6-localnet</div><div class="line">ff00::0	ip6-mcastprefix</div><div class="line">ff02::1	ip6-allnodes</div><div class="line">ff02::2	ip6-allrouters</div><div class="line">192.168.0.1	biaoge-ops</div><div class="line">10.0.0.3	6ff3ea7114b4</div></pre></td></tr></table></figure>
<p>个人博客：<a href="https://my.oschina.net/xxbAndy/blog" target="_blank" rel="external">https://my.oschina.net/xxbAndy/blog</a><br>微信公众号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577135-5d2191eacf61c6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechat.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用docker过程中，我们经常发现管理维护是一个很复杂过程，因为我们在使用docker commands的过程中，我们只会去使用我们认为简单并且熟悉的命令，然而docker本身其实是提供给我们很多便捷且人性化的工具的，如果掌握这些使用技巧，也许你的维护管理工作将会事半功倍，并且给人看起来会很牛逼的样子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile最佳实践</title>
    <link href="http://yoursite.com/2017/11/09/Dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2017/11/09/Dockerfile最佳实践/</id>
    <published>2017-11-09T13:40:51.000Z</published>
    <updated>2017-12-10T13:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在生产环境中一般我们会对基本的环境进行自构建，从而利用images的分层特性去层层构建上层的业务镜像。</strong></p>
<blockquote>
<p>1.默认情况下我们会首先构建一个基本的base镜像，这个镜像可能包含了linux具体的发行版本，以及基本的软件包，比如wget，vi等。在该层面上，镜像的改动会很少，频次也会很低。 </p>
<p>2.其次我们可以在base镜像之上构建新的平台镜像，比如说ssh，java，tomcat等。在基础环境层，相比较上一层来说修改频次稍微会有点大，因为可能涉及到基本软件的版本调整或者参数调整。</p>
<p>3.然后在可以在基本的平台镜像之上构建业务镜像，业务镜像是可以直接启动应用程序的，也就是需要启动服务进程的。该层镜像就是直接和业务代码融合的镜像，随着业务的更新，镜像也会频繁的改动上线。</p>
</blockquote>
<a id="more"></a>
<p><strong><code>问题：如果我们构建业务镜像中默认需要启动多个服务，比如需要启动sshd和tomcat或者是一个nginx，那么就不能通过构建镜像的时候去使用CMD命令，因为CMD命令会继承上层images的CMD命令，从而导致上层的CMD命令失效。那么想要既继承上层的sshd，又需要启动业务进程，普通的方式可以采用脚本定义，并在业务镜像层进行RUN脚本。</code></strong></p>
<p><strong>所以比较好的方法：使用supervisord来管理images中的多个服务进程。可以在基本镜像层进行构建supervisord镜像，然后在上层业务层通过配置supervisord.conf来管理对个进程，实现一个容器中启动多个服务进程。</strong></p>
<h3 id="构建无需启动服务的pass层镜像"><a href="#构建无需启动服务的pass层镜像" class="headerlink" title="构建无需启动服务的pass层镜像"></a>构建无需启动服务的pass层镜像</h3><p>该环节是提供给用户基本的软件运行环境，用户可以通过bash登录去启动业务程序。而根据业务的变化特征，以及基础服务的抽象程度，我们可以将该层的image镜像分成以下三个image进行叠加。</p>
<h4 id="构建符合实际业务场景的base镜像"><a href="#构建符合实际业务场景的base镜像" class="headerlink" title="构建符合实际业务场景的base镜像"></a>构建符合实际业务场景的base镜像</h4><p><code>注意：</code>给image中打入sshd服务的主要原因还是想尽可能的满足用户当前的使用习惯，同时又能够充分利用docker image的特性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">FROM centos6.8-base</div><div class="line">MAINTAINER xuxuebiao</div><div class="line">RUN ssh-keygen -q -N &quot;&quot; -t dsa -f /etc/ssh/ssh_host_dsa_key ;\</div><div class="line">    ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key ;\</div><div class="line">    sed -ri &apos;s/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/g&apos; /etc/pam.d/sshd ;\</div><div class="line">    mkdir -p /root/.ssh &amp;&amp; chown root.root /root &amp;&amp; chmod 700 /root/.ssh ;\</div><div class="line">    sed -ri &apos;s/#Port 22/Port 52568/g&apos; /etc/ssh/sshd_config ;\</div><div class="line">    echo &apos;root:redhat&apos; | chpasswd</div><div class="line">EXPOSE 52568</div><div class="line">ENV LANG=zh_CN.UTF-8;\</div><div class="line">    LC_ALL=zh_CN.UTF-8;\</div><div class="line">    TZ &quot;Asia/Shanghai&quot;;\</div><div class="line">    TERM xterm</div><div class="line">CMD /usr/sbin/sshd -D</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#docker build -t centos6.8-sshd .</div></pre></td></tr></table></figure>
<hr>
<h4 id="构建上层基本软件环境"><a href="#构建上层基本软件环境" class="headerlink" title="构建上层基本软件环境"></a>构建上层基本软件环境</h4><p><code>注意：上层SSHD镜像默认使用CMD启动了一个sshd服务，因此这层PAAS层无法直接启动nginx和tomcat，本层只是构建了一个基本环境，容器启动后需要登录bash中执行脚本进行启动。这样交付的环境其实就相当于PAAS层的环境</code></p>
<p>构建一个基于jdk7tomcat6的基本镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">FROM centos6.8-sshd</div><div class="line">MAINTAINER &quot;xuxuebiao&quot;</div><div class="line">ENV TZ &quot;Asia/Shanghai&quot;;\</div><div class="line">    PATH $PATH:/export/data/</div><div class="line"></div><div class="line">RUN useradd admin;\</div><div class="line">    mkdir -p /export/servers/&#123;jdk1.7.0_71,tomcat6.0.33,nginx&#125;;\</div><div class="line">    mkdir -p /export/&#123;App,auto_deploy,Config,data,Data,Domains,home,Logs,servers,Shell&#125;;</div><div class="line">WORKDIR /export/data/</div><div class="line">EXPOSE 80</div><div class="line">EXPOSE 8080</div><div class="line">ADD jdk1.7.0_71  /export/servers/jdk1.7.0_71</div><div class="line">ADD tomcat6.0.33 /export/servers/tomcat6.0.33</div><div class="line">ADD profile /etc/profile</div><div class="line">ADD nginx  /export/servers/nginx</div><div class="line">ADD auto-add-tomcat /home/admin/</div><div class="line">COPY start_nginx /etc/init.d/nginx</div><div class="line">COPY init_nginx.sh /export/Shell/</div><div class="line">RUN chmod a+x /etc/init.d/nginx;\</div><div class="line">    chmod a+x /export/Shell/init_nginx.sh;\</div><div class="line">    chown admin.admin -R /export/ /home/admin/</div></pre></td></tr></table></figure>
<p>构建一个基于python27的基本环境，环境中本身已经安装各种第三方程序库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM centos6.8-sshd</div><div class="line">MAINTAINER biaoge</div><div class="line">ADD python27 /usr/local/python27</div><div class="line">RUN ln -s /usr/local/python27/bin/python2.7 /usr/local/bin/python27 ;\</div><div class="line">    ln -s  /usr/local/python27/bin/pip /usr/local/bin/pip;\</div><div class="line">    ln -s /usr/local/python27/bin/ipython /usr/local/bin/ipython;</div><div class="line"></div><div class="line">EXPOSE 8000</div><div class="line">EXPOSE 8081</div></pre></td></tr></table></figure>
<p><code>构建本层的镜像Dockerfile中不能指定新的应用进程，否则基本镜像中的sshd就会失效</code></p>
<hr>
<h3 id="构建开箱即用的SaaS层镜像-容器启动之后即可提供相应的服务。比如nginx，sshd等"><a href="#构建开箱即用的SaaS层镜像-容器启动之后即可提供相应的服务。比如nginx，sshd等" class="headerlink" title="构建开箱即用的SaaS层镜像(容器启动之后即可提供相应的服务。比如nginx，sshd等)"></a>构建开箱即用的SaaS层镜像(容器启动之后即可提供相应的服务。比如nginx，sshd等)</h3><h4 id="首先使用base镜像构建一层的supervisord基本镜像"><a href="#首先使用base镜像构建一层的supervisord基本镜像" class="headerlink" title="首先使用base镜像构建一层的supervisord基本镜像"></a>首先使用base镜像构建一层的supervisord基本镜像</h4><p><code>由于supervisord是有python写的，所以可以直接在python模块包中使用</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">FROM centos6.8-base</div><div class="line">MAINTAINER biaoge</div><div class="line">ENV LANG=zh_CN.UTF-8;\</div><div class="line">    LC_ALL=zh_CN.UTF-8;\</div><div class="line">    TZ=&quot;Asia/Shanghai&quot;;\</div><div class="line">    TERM=xterm</div><div class="line">ADD python27 /usr/local/python27</div><div class="line">RUN ln -s /usr/local/python27/bin/python2.7 /usr/local/bin/python27 ;\</div><div class="line">    ln -s  /usr/local/python27/bin/pip /usr/local/bin/pip;\</div><div class="line">    ln -s /usr/local/python27/bin/ipython /usr/local/bin/ipython;\</div><div class="line">    ln -s /usr/local/python27/bin/supervisord /usr/local/bin/supervisord;</div><div class="line"></div><div class="line">ADD supervisord.conf /etc/supervisord.conf</div><div class="line">EXPOSE 8000 8001 </div><div class="line"></div><div class="line">CMD [&quot;/usr/local/bin/supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;]</div><div class="line">#这里其实比较建议使用ENTRYPOINT</div><div class="line">#ENTRYPOINT通常情况下和CMD会一起使用，区别是CMD定义的执行命令会被container创建的时候的command取代。一般情况下ENTRYPOINT会定义命令执行的主体,CMD中增加默认的参数，而实际的参数可以通过创建container的时候用command进行优化选择</div><div class="line">#ENTRYPOINT  [&quot;/usr/local/bin/supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;]</div><div class="line">#文末会有演示一个ENTRYPOINT的例子</div></pre></td></tr></table></figure>
<p>启动之后就会默认启动supervisord.conf中配的服务。</p>
<p>默认的supervisord.conf文件配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[supervisord]</div><div class="line">http_port=/var/tmp/supervisor.sock ; (default is to run a UNIX domain socket server)</div><div class="line">logfile=/var/log/supervisord.log ; (main log file;default $CWD/supervisord.log)</div><div class="line">logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</div><div class="line">logfile_backups=10          ; (num of main logfile rotation backups;default 10)</div><div class="line">loglevel=info               ; (logging level;default info; others: debug,warn)</div><div class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</div><div class="line">nodaemon=true              ; (start in foreground if true;default false)</div><div class="line">minfds=1024                 ; (min. avail startup file descriptors;default 1024)</div><div class="line">minprocs=200                ; (min. avail process descriptors;default 200)</div><div class="line"></div><div class="line"></div><div class="line">[supervisorctl]</div><div class="line">serverurl=unix:///var/tmp/supervisor.sock ; use a unix:// URL  for a unix socket</div><div class="line"></div><div class="line">#额外管理的服务</div><div class="line">#[program:httpd]</div><div class="line">#command = /usr/sbin/httpd</div><div class="line">#[program:sshd]</div><div class="line">#command = /usr/sbin/sshd -D</div></pre></td></tr></table></figure>
<h4 id="使用上面构建的supervisord镜像进行构建服务镜像"><a href="#使用上面构建的supervisord镜像进行构建服务镜像" class="headerlink" title="使用上面构建的supervisord镜像进行构建服务镜像"></a>使用上面构建的supervisord镜像进行构建服务镜像</h4><p>镜像可自启动包含sshd和rabbitmq的服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FROM supversord</div><div class="line">MAINTAINER biaoge</div><div class="line"></div><div class="line">#需要如下相关的包</div><div class="line">#esl-erlang_18.1-1~centos~6_amd64.rpm  esl-erlang-compat-18.1-1.noarch.rpm  rabbitmq-server-3.1.5-1.noarch.rpm</div><div class="line">COPY *.rpm /usr/local/</div><div class="line">RUN yum localinstall /usr/local/*.rpm -y </div><div class="line">RUN ssh-keygen -q -N &quot;&quot; -t dsa -f /etc/ssh/ssh_host_dsa_key ;\</div><div class="line">    ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key ;\</div><div class="line">    sed -ri &apos;s/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/g&apos; /etc/pam.d/sshd ;\</div><div class="line">    mkdir -p /root/.ssh &amp;&amp; chown root.root /root &amp;&amp; chmod 700 /root/.ssh ;\</div><div class="line">    sed -ri &apos;s/#Port 22/Port 52568/g&apos; /etc/ssh/sshd_config ;\</div><div class="line">    echo &apos;root:redhat&apos; | chpasswd</div><div class="line">EXPOSE 52568 5672 4369 </div><div class="line"></div><div class="line">#这里只需要将更新的配置文件拷贝进去，最终会继承父进程中的CMD去执行supervisord中定义的服务</div><div class="line">ADD supervisord.conf /etc/supervisord.conf</div></pre></td></tr></table></figure>
<p>用来启动sshd和rabbitmq服务的<code>supervisord.conf</code>配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[supervisord]</div><div class="line">http_port=/var/tmp/supervisor.sock ; (default is to run a UNIX domain socket server)</div><div class="line">logfile=/var/log/supervisord.log ; (main log file;default $CWD/supervisord.log)</div><div class="line">logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</div><div class="line">logfile_backups=10          ; (num of main logfile rotation backups;default 10)</div><div class="line">loglevel=info               ; (logging level;default info; others: debug,warn)</div><div class="line">pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</div><div class="line">nodaemon=true              ; (start in foreground if true;default false)</div><div class="line">minfds=1024                 ; (min. avail startup file descriptors;default 1024)</div><div class="line">minprocs=200                ; (min. avail process descriptors;default 200)</div><div class="line"></div><div class="line"></div><div class="line">[supervisorctl]</div><div class="line">serverurl=unix:///var/tmp/supervisor.sock ; use a unix:// URL  for a unix socket</div><div class="line"></div><div class="line">#额外管理的服务</div><div class="line">[program:rabbitmq]</div><div class="line">command = rabbitmq-server</div><div class="line">[program:sshd]</div><div class="line">command = /usr/sbin/sshd -D</div></pre></td></tr></table></figure>
<p><strong>测试访问：</strong><br>使用上面Dockerfile创建images进行构建容器：</p>
<blockquote>
<p>$docker run -itd –name test-ssh sshd-rabbitmq </p>
</blockquote>
<p>发现创建的容器，已经通过上面的supervisord.conf中定义好的，启动了rabbitmq和sshd服务。</p>
<h3 id="构建基于PaaS层的其他基本镜像"><a href="#构建基于PaaS层的其他基本镜像" class="headerlink" title="构建基于PaaS层的其他基本镜像"></a>构建基于PaaS层的其他基本镜像</h3><p>基本sshd镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">FROM supervisord</div><div class="line">MAINTAINER 371990778@qq.com</div><div class="line">#配置相关的ssh需要的文件，以及相关的用户密码</div><div class="line">RUN ssh-keygen -q -N &quot;&quot; -t dsa -f /etc/ssh/ssh_host_dsa_key ;\</div><div class="line">    ssh-keygen -q -N &quot;&quot; -t rsa -f /etc/ssh/ssh_host_rsa_key ;\</div><div class="line">    sed -ri &apos;s/session    required     pam_loginuid.so/#session    required     pam_loginuid.so/g&apos; /etc/pam.d/sshd ;\</div><div class="line">    mkdir -p /root/.ssh &amp;&amp; chown root.root /root &amp;&amp; chmod 700 /root/.ssh ;\</div><div class="line">    sed -ri &apos;s/#Port 22/Port 52568/g&apos; /etc/ssh/sshd_config ;\</div><div class="line">    echo &apos;root:redhat&apos; | chpasswd</div><div class="line">EXPOSE 52568</div><div class="line"></div><div class="line">#这里只需要将更新的配置文件拷贝进去，最终会继承父进程中的CMD去执行supervisord中定义的服务</div><div class="line">ADD supervisord.conf /etc/supervisord.conf</div></pre></td></tr></table></figure>
<p><code>相应的supervisord.conf文件中只需要增加相应的额服务启动命令</code></p>
<p>基本redis镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FROM sshd-base</div><div class="line">MAINTAINER biaoge</div><div class="line">ADD redis-2.8.9 /usr/local/redis-2.8.9 </div><div class="line">#ADD redis.conf /etc/redis.conf</div><div class="line">RUN ln -s /usr/local/redis-2.8.9/src/redis-cli /usr/local/bin/redis-cli ;\</div><div class="line">    ln -s /usr/local/redis-2.8.9/src/redis-server /usr/local/bin/redis-server;\</div><div class="line">    ln -s /usr/local/redis-2.8.9/redisd.sh /usr/local/bin/redisd.sh</div><div class="line"></div><div class="line">EXPOSE 3679 </div><div class="line">ADD supervisord.conf /etc/supervisord.conf</div><div class="line">#CMD /usr/local/bin/redis-server</div></pre></td></tr></table></figure>
<p>基本rabbit镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">FROM sshd-base</div><div class="line">MAINTAINER biaoge</div><div class="line"></div><div class="line">#需要如下相关的包</div><div class="line">#esl-erlang_18.1-1~centos~6_amd64.rpm  esl-erlang-compat-18.1-1.noarch.rpm  rabbitmq-server-3.1.5-1.noarch.rpm</div><div class="line">COPY *.rpm /usr/local/</div><div class="line">RUN yum localinstall /usr/local/*.rpm -y </div><div class="line">EXPOSE 5672 4369 </div><div class="line"></div><div class="line">#这里只需要将更新的配置文件拷贝进去，最终会继承父进程中的CMD去执行supervisord中定义的服务</div><div class="line">ADD supervisord.conf /etc/supervisord.conf</div></pre></td></tr></table></figure>
<p><strong>其他案例示范：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM centos:6.8</div><div class="line">MAINTAINER &quot;Andy_xu&quot;</div><div class="line"></div><div class="line">ENV TZ &quot;Asia/Shanghai&quot;</div><div class="line">#ENV PATH $PATH:/export/data/</div><div class="line">ENV TERM xterm</div><div class="line"></div><div class="line">RUN mkdir -p /export/package</div><div class="line">COPY * /export/package</div></pre></td></tr></table></figure>
<p><code>注意：上面dockerfile文件构建的环境没有默认的ps，需要加载export PS1=&#39;[\u@\h \W]\$&#39;</code></p>
<p>ENTRYPOINT 指令详解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ cat Dockerfile</div><div class="line">FROM centos6.8</div><div class="line">ENTRYPOINT [&quot;curl&quot;,&quot;-s&quot;,&quot;10.0.0.1:2379/info&quot;]</div><div class="line">#cmd 可以只定义参数</div><div class="line">#CMD [&quot;-v&quot;]</div><div class="line">$ docker build -t curl .</div><div class="line">$ docker  run curl  (执行ENTRYPOINT定义的内容)</div><div class="line">&#123;&quot;ID&quot;:&quot;RDTS:INFK:VAZI:5X75:EYAP:DBTC:AQ42:A5WH:IVJX:K4L2:RJ2R:CZS2&quot;,&quot;Containers&quot;:21,&quot;Images&quot;:150,&quot;Driver&quot;:&quot;overlay&quot;,&quot;DriverStatus&quot;:[[&quot;Backing Filesystem&quot;,&quot;extfs&quot;]],&quot;MemoryLimit&quot;:true,&quot;SwapLimit&quot;:true,&quot;CpuCfsPeriod&quot;:true,&quot;CpuCfsQuota&quot;:true,&quot;IPv4Forwarding&quot;:true,&quot;BridgeNfIptables&quot;:true,&quot;BridgeNfIp6tables&quot;:true,&quot;Debug&quot;:false,&quot;NFd&quot;:42,&quot;OomKillDisable&quot;:true,&quot;NGoroutines&quot;:84,&quot;SystemTime&quot;:&quot;2017-05-19T10:51:57.545371359+08:00&quot;,&quot;ExecutionDriver&quot;:&quot;native-0.2&quot;,&quot;LoggingDriver&quot;:&quot;json-file&quot;,&quot;NEventsListener&quot;:0,&quot;KernelVersion&quot;:&quot;2.6.32-431.wy39.el6.x86_64&quot;,&quot;OperatingSystem&quot;:&quot;\u003cunknown\u003e&quot;,&quot;IndexServerAddress&quot;:&quot;https://index.docker.io/v1/&quot;,&quot;RegistryConfig&quot;:&#123;&quot;InsecureRegistryCIDRs&quot;:[&quot;127.0.0.0/8&quot;],&quot;IndexConfigs&quot;:&#123;&quot;xxbandy123&quot;:&#123;&quot;Name&quot;:&quot;172.25.46.9:5001&quot;,&quot;Mirrors&quot;:[],&quot;Secure&quot;:false,&quot;Official&quot;:false&#125;,&quot;docker.io&quot;:&#123;&quot;Name&quot;:&quot;docker.io&quot;,&quot;Mirrors&quot;:null,&quot;Secure&quot;:true,&quot;Official&quot;:true&#125;&#125;,&quot;Mirrors&quot;:null&#125;,&quot;InitSha1&quot;:&quot;&quot;,&quot;InitPath&quot;:&quot;/usr/bin/docker&quot;,&quot;NCPU&quot;:40,&quot;MemTotal&quot;:135282294784,&quot;DockerRootDir&quot;:&quot;/export/lib/docker&quot;,&quot;HttpProxy&quot;:&quot;&quot;,&quot;HttpsProxy&quot;:&quot;&quot;,&quot;NoProxy&quot;:&quot;&quot;,&quot;Name&quot;:&quot;HC-25-28-12.h.chinabank.com.cn&quot;,&quot;Labels&quot;:null,&quot;ExperimentalBuild&quot;:false,&quot;ServerVersion&quot;:&quot;1.9.1&quot;,&quot;ClusterStore&quot;:&quot;&quot;,&quot;ClusterAdvertise&quot;:&quot;&quot;&#125;</div><div class="line"></div><div class="line">$ docker  run curl -v -I (ENTRYPOINT后面可以增加自定义参数，会覆盖掉Dockerfile中掉CMD指令)</div><div class="line">* About to connect() to 10.0.0.1 port 5256 (#0)</div><div class="line">*   Trying 10.0.0.1... connected</div><div class="line">* Connected to 10.0.0.1 (10.0.0.1) port 5256 (#0)</div><div class="line">&gt; HEAD /info HTTP/1.1</div><div class="line">&gt; User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.21 Basic ECC zlib/1.2.3 libidn/1.18 libssh2/1.4.2</div><div class="line">&gt; Host: 10.0.0.1:5256</div><div class="line">&gt; Accept: */*</div><div class="line">&gt;</div><div class="line">&lt; HTTP/1.1 404 Not Found</div><div class="line">&lt; Content-Type: text/plain; charset=utf-8</div><div class="line">&lt; Date: Fri, 19 May 2017 02:53:36 GMT</div><div class="line">&lt; Content-Length: 19</div><div class="line">&lt;</div><div class="line">* Connection #0 to host 10.0.0.1 left intact</div><div class="line">* Closing connection #0</div><div class="line">HTTP/1.1 404 Not Found</div><div class="line">Content-Type: text/plain; charset=utf-8</div><div class="line">Date: Fri, 19 May 2017 02:53:36 GMT</div><div class="line">Content-Length: 19</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在生产环境中一般我们会对基本的环境进行自构建，从而利用images的分层特性去层层构建上层的业务镜像。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.默认情况下我们会首先构建一个基本的base镜像，这个镜像可能包含了linux具体的发行版本，以及基本的软件包，比如wget，vi等。在该层面上，镜像的改动会很少，频次也会很低。 &lt;/p&gt;
&lt;p&gt;2.其次我们可以在base镜像之上构建新的平台镜像，比如说ssh，java，tomcat等。在基础环境层，相比较上一层来说修改频次稍微会有点大，因为可能涉及到基本软件的版本调整或者参数调整。&lt;/p&gt;
&lt;p&gt;3.然后在可以在基本的平台镜像之上构建业务镜像，业务镜像是可以直接启动应用程序的，也就是需要启动服务进程的。该层镜像就是直接和业务代码融合的镜像，随着业务的更新，镜像也会频繁的改动上线。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Dockerfile" scheme="http://yoursite.com/tags/Dockerfile/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Overlayfs技术探究以及Docker环境中的使用</title>
    <link href="http://yoursite.com/2017/11/09/Overlayfs%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6%E4%BB%A5%E5%8F%8ADocker%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/09/Overlayfs技术探究以及Docker环境中的使用/</id>
    <published>2017-11-09T13:36:58.000Z</published>
    <updated>2017-11-09T13:44:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="overlayfs-基本概念"><a href="#overlayfs-基本概念" class="headerlink" title="overlayfs 基本概念"></a>overlayfs 基本概念</h3><p>一种联合文件系统，设计简单，速度更快。overlayfs在linux主机上只有两层，一个目录在下层，用来保存镜像(docker)，另外一个目录在上层，用来存储容器信息。在overlayfs中，底层的目录叫做lowerdir，顶层的目录称之为upperdir，对外提供统一的文件系统为merged。<br>当需要修改一个文件时，使用CoW将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container。<br><a id="more"></a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577135-efb7ae4b8b44c1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="overlayfs存储架构"><br><code>可以看到镜像层和容器层可以保存相同的文件，容器层的文件会覆盖镜像层的文件</code></p>
<ul>
<li>在overlayfs中每个镜像层都会在<code>/var/lib/docker/overlay</code>有对应的目录，使用硬链接与底层数据进行关联。</li>
</ul>
<h3 id="优势劣势"><a href="#优势劣势" class="headerlink" title="优势劣势"></a>优势劣势</h3><ul>
<li><strong>1.OverlayFS支持页缓存共享，多个容器访问同一个文件能共享一个页缓存，以此提高内存使用</strong></li>
<li><strong>2.OverlayFS消耗inode，随着镜像和容器增加，inode会遇到瓶颈。Overlay2能解决这个问题。在Overlay下，为了解决inode问题，可以考虑将/var/lib/docker挂在单独的文件系统上，或者增加系统inode设置。</strong></li>
</ul>
<h3 id="overlay中的读写"><a href="#overlay中的读写" class="headerlink" title="overlay中的读写"></a>overlay中的读写</h3><h4 id="在容器中读取文件"><a href="#在容器中读取文件" class="headerlink" title="在容器中读取文件"></a>在容器中读取文件</h4><ul>
<li><p>(1)目标文件不在容器层内，overlay会从镜像层读取文件，此时，对容器性能的影响很小。</p>
</li>
<li><p>(2)目标文件在容器层内，overlay直接从容器层读取。</p>
</li>
<li>(3)目标文件在容器层和镜像层同时存在，overlay读入容器层中的文件，此时容器层的文件会覆盖镜像层的文件。</li>
</ul>
<h4 id="在容器中修改文件"><a href="#在容器中修改文件" class="headerlink" title="在容器中修改文件"></a>在容器中修改文件</h4><p>在容器中第一次修改文件，此时文件不在容器层中。overlay会把文件从镜像层复制到容器层，所有该文件中的修改都保存在容器层中。</p>
<p><code>注意：</code>overlay工作文件系统层(devicemapper工作再块层面)，因此复制文件会复制整个文件，因此在频繁读写会很消耗资源</p>
<ul>
<li><p>(1)只是在第一次修改文件时，需要把文件从镜像层复制到容器层，后续操作都是在容器层中完成。</p>
</li>
<li><p>(2)overlayfs只有两层，lowerdir和upperdir，因此在很深的目录树中，搜索文件会相对比较快</p>
</li>
</ul>
<h4 id="在容器中删除文件和目录"><a href="#在容器中删除文件和目录" class="headerlink" title="在容器中删除文件和目录"></a>在容器中删除文件和目录</h4><p>在容器中删除文件时，overlay存储驱动在容器层中新建一个without文件，该文件用语隐藏镜像层中的目标文件。在容器层删除目录时，overlay存储驱动在容器层新建一个opaque目录，该目录用于隐藏镜像层中的目标目录。<br>需要明白的一点是，任何存储驱动都不会删除底层image中的目标文件和目录的。</p>
<h4 id="overlayfs的原理测试"><a href="#overlayfs的原理测试" class="headerlink" title="overlayfs的原理测试"></a>overlayfs的原理测试</h4><p>overlayfs挂载后系统文件的page cache是全部共享的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"># mkdir low upper work</div><div class="line"># ls</div><div class="line">low  upper  work</div><div class="line"># echo &apos;abs&apos; &gt; low/11.txt</div><div class="line"># echo &apos;xuxuebiao&apos; &gt; upper/22.txt</div><div class="line"># mkdir merged</div><div class="line"># mount -t overlay overlay -olowerdir=./low,upperdir=./upper,workdir=./work ./merged</div><div class="line"># ls</div><div class="line">low  merged  upper  work</div><div class="line"># cd merged/</div><div class="line"># ls</div><div class="line">11.txt  22.txt</div><div class="line"># ll</div><div class="line">total 8</div><div class="line">-rw-r--r--. 1 root root  4 Mar 27 18:57 11.txt</div><div class="line">-rw-r--r--. 1 root root 10 Mar 27 18:58 22.txt</div><div class="line"></div><div class="line"># tree</div><div class="line">.</div><div class="line">├── low</div><div class="line">│   └── 11.txt</div><div class="line">├── merged</div><div class="line">│   ├── 11.txt</div><div class="line">│   └── 22.txt</div><div class="line">├── upper</div><div class="line">│   └── 22.txt</div><div class="line">└── work</div><div class="line">    └── work</div><div class="line"></div><div class="line">5 directories, 4 files</div><div class="line">可以看到，merged目录中时low和upper目录联合的结果</div><div class="line"></div><div class="line"></div><div class="line">分别修改文件：</div><div class="line"># cat 11.txt</div><div class="line">abs</div><div class="line"># cat 22.txt</div><div class="line">xuxuebiao</div><div class="line"># vim 11.txt</div><div class="line"># cat 11.txt</div><div class="line">Hello ,overlayfs!</div><div class="line"># cat ../low/11.txt</div><div class="line">abs</div><div class="line"># cat ../upper/</div><div class="line">11.txt   11.txt~  22.txt</div><div class="line"># cat ../upper/11.txt</div><div class="line">Hello ,overlayfs!</div><div class="line"># cat ../upper/11.txt~</div><div class="line">cat: ../upper/11.txt~: No such device or address</div><div class="line"># cat ../upper/11.txt</div><div class="line">11.txt   11.txt~</div><div class="line"># cat ../upper/11.txt~</div><div class="line">cat: ../upper/11.txt~: No such device or address</div><div class="line"></div><div class="line">可以看到low目录下的文件没有变化，但是upper里面的文件内容已经改变，并且有了一个11.txt~文件</div><div class="line"></div><div class="line"></div><div class="line"># ls -i ../upper/11.txt 11.txt</div><div class="line">143902921 11.txt  143902921 ../upper/11.txt</div><div class="line">可以看到upper和merged目录中的两个文件11.txt的inode其实是一致的，其实是硬链接</div><div class="line"></div><div class="line"># ls -i ../low/11.txt 11.txt</div><div class="line">143902921 11.txt  143902918 ../low/11.txt</div><div class="line">merged目录文件和low目录文件对比</div><div class="line"></div><div class="line"></div><div class="line">删除文件测试：</div><div class="line"># rm 11.txt</div><div class="line">rm: remove regular file ‘11.txt’? y</div><div class="line"># ls</div><div class="line">ls: cannot access 11.txt: No such file or directory</div><div class="line">ls: cannot access 11.txt~: No such file or directory</div><div class="line">11.txt  11.txt~  22.txt</div><div class="line"></div><div class="line"># cat ../upper/11.txt~</div><div class="line">cat: ../upper/11.txt~: No such device or address</div><div class="line"># ls -l ../upper/11.txt</div><div class="line">c---------. 1 root root 0, 0 Mar 27 19:08 ../upper/11.txt</div><div class="line"></div><div class="line">删除文件后发现文件无法访问，底层变成了一个大小为0，且没有任何人有权限的一个空文件。</div><div class="line">overlayfs用这种删除标记的方式标识文件被删除，（如果upper中没有该文件的话，则底层low中的同名文件又恢复出来显示了，因此需要有这个空文件来标识删除，并且覆盖底层的文件）</div></pre></td></tr></table></figure>
<h3 id="overlayfs在docker中的使用"><a href="#overlayfs在docker中的使用" class="headerlink" title="overlayfs在docker中的使用"></a>overlayfs在docker中的使用</h3><blockquote>
<p>首先，overlayfs是在高版本的内核上才支持的存储驱动，因此不管使用的官方内核，还是自己patch的内核，首先需要检查overlayfs是否被加载</p>
</blockquote>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4OTMxODQwNA==&amp;mid=2650978252&amp;idx=1&amp;sn=4e5040d70d5656d9b937eb7e9dbc672a&amp;mpshare=1&amp;scene=1&amp;srcid=0327J9rVlXF0m4VU4b0raAJQ&amp;key=7601aed56c2d62eb663f9c44acf41d0f3071fe13b7a35bd0e12641eef7aa201e53e5b9c680e04104a3c41e77eb9d2507aa4613cfac95837e6ae6a7e52710866fd11284eb8814fcf5ab872552099d0a8c&amp;ascene=0&amp;uin=MjUxNzI2NjE2Mg%3D%3D&amp;devicetype=iMac+MacBookAir7%2C2+OSX+OSX+10.10.5+build(14F1021" target="_blank" rel="external">overlayfs</a>&amp;version=11020201&amp;pass_ticket=gNSbIAbFM0u3hxIEr27nbXmZMTLnAbzlRuhwjwSUx8jm0iwFbqx9VvM799FvRrSB)</p>
<p>并且同样重要的是，对于aufs和overlay的实现，用来读取或执行共享库的共享内存也在所有运行的容器之间共享，大大的减少了通用库如’libc’的内存占用。这是一个分层策略的巨大优势，同时也是Docker的graphdriver是引擎中相当重要的一部分的原因之一。graphdriver的功能作用。</p>
<ul>
<li>1.检查overlay是否被加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">查看overlay是否被加载</div><div class="line">$ lsmod | grep overlay</div><div class="line">查看内核是否支持overlay模块</div><div class="line">$ modinfo overlayfs</div><div class="line">加载内核模块</div><div class="line">$ modprobe overlayfs</div></pre></td></tr></table></figure>
<ul>
<li>2.docker启动参数修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">检测overlayfs释放被识别，成功启动后修改参数到默认的配置文件中</div><div class="line">$ docker daemon(dockerd) -s overlay(--storage-driver=overlay) </div><div class="line"></div><div class="line">修改配置文件</div><div class="line">$ cat /etc/sysconfig/docker.conf</div><div class="line">DOCKER_OPTS=&quot;--storage-driver=overlay&quot;</div><div class="line"></div><div class="line">模拟配置:</div><div class="line">other_args=&quot;-s overlay --graph=/export/lib/docker -H unix:///var/run/docker.sock --bip 10.0.0.1/24 -H 0.0.0.0:5256  --api-enable-cors=true&quot;</div></pre></td></tr></table></figure>
<ul>
<li>3.检验overlayfs是否成功启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ sudo /etc/init.d/docker restart</div><div class="line">成功启动，查看存储信息：</div><div class="line">$ sudo docker info</div><div class="line">Containers: 11</div><div class="line">Images: 5</div><div class="line">Server Version: 1.9.1</div><div class="line">Storage Driver: overlay</div><div class="line"> Backing Filesystem: extfs</div><div class="line">Execution Driver: native-0.2</div><div class="line">Logging Driver: json-file</div><div class="line">Kernel Version: 2.6.32-431.wy38.el6.x86_64</div><div class="line">Operating System: &lt;unknown&gt;</div><div class="line">CPUs: 32</div><div class="line">Total Memory: 126 GiB</div><div class="line">Name: －－－－－</div><div class="line">ID: 2IER:NO5S:4NKX:ULDJ:THGQ:GBNR:NIN6:SCXG:SMFX:PG72:JAQF:GRZW</div><div class="line"></div><div class="line">可用看到相关存储驱动是overlay，文件系统是extfs</div></pre></td></tr></table></figure>
<ul>
<li>4.overlay在docker上面的使用</li>
</ul>
<p><code>默认docker会将容器以及镜像相关的文件存储在/var/lib/docker/overlay目录下</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">sh-4.1# docker  images</div><div class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</div><div class="line">xxbandy123/centos6.8-sshd   latest              42c75e16533e        12 weeks ago        402 MB</div><div class="line">sh-4.1# pwd  （这里我们是配置了存储路径）</div><div class="line">/export/lib/docker/overlay</div><div class="line"></div><div class="line">sh-4.1# ll -t</div><div class="line">total 28</div><div class="line">drwx------ 4 root root 4096 Mar 31 10:37 8ab8690b0769d07cc0b546112cfc40068d99298ed7e1857272c98a522cede527</div><div class="line">drwx------ 4 root root 4096 Mar 31 10:37 8ab8690b0769d07cc0b546112cfc40068d99298ed7e1857272c98a522cede527-init</div><div class="line">drwx------ 3 root root 4096 Mar 31 10:35 42c75e16533e2ef46ffd22a21318d354b3f3e520709230e9848ebaca8f1f514e</div><div class="line">drwx------ 3 root root 4096 Mar 31 10:35 b46ba152cc17054229bc0099e7fda8b34958d518ce687c0d378b4832c4d8c91e</div><div class="line">drwx------ 3 root root 4096 Mar 31 10:35 9016bb11dc9b4a3ee23fbef484cf5b3c9b80491e87d67092febec45759baeb4f</div><div class="line">drwx------ 3 root root 4096 Mar 31 10:35 ea80c789cb2b3bcc1d12b9b3226c8482a06f28e94a4a49f8e201b5e9cdbdf0cc</div><div class="line">drwx------ 3 root root 4096 Mar 31 10:35 e444e2175366cd3507bc9278d9a68a7b7ca5759b364bfe960fc12a87f219e847</div><div class="line"></div><div class="line">可用看到我们现在有一个image，id为42c75e16533e,overlay会把该镜像的所有父镜像存储到本地(image的分层缓存)，该image共5层。</div><div class="line">sh-4.1# docker  inspect 42c75e16533e | grep b46ba152cc1</div><div class="line">    &quot;Parent&quot;: &quot;b46ba152cc17054229bc0099e7fda8b34958d518ce687c0d378b4832c4d8c91e&quot;,</div><div class="line">sh-4.1# docker  inspect b46ba152cc1 | grep 9016bb11dc9b4a</div><div class="line">    &quot;Parent&quot;: &quot;9016bb11dc9b4a3ee23fbef484cf5b3c9b80491e87d67092febec45759baeb4f&quot;,</div><div class="line">sh-4.1# docker  inspect 9016bb11dc9b4a | grep ea80c789cb2</div><div class="line">    &quot;Parent&quot;: &quot;ea80c789cb2b3bcc1d12b9b3226c8482a06f28e94a4a49f8e201b5e9cdbdf0cc&quot;,</div><div class="line">sh-4.1# docker  inspect ea80c789cb2 | grep e444e2175366cd35</div><div class="line">    &quot;Parent&quot;: &quot;e444e2175366cd3507bc9278d9a68a7b7ca5759b364bfe960fc12a87f219e847&quot;,</div><div class="line">sh-4.1# docker  inspect e444e2175366cd35 | grep Parent</div><div class="line">    &quot;Parent&quot;: &quot;&quot;,</div><div class="line">sh-4.1#</div><div class="line"></div><div class="line"></div><div class="line">由下面示例可以看到容器id 8ab8690b07，实际上是使用image 42c75e16533e 启动起来的一个container，并给出了container 的LowerDir:`/export/lib/docker/overlay/42c75e16533e2ef46ffd22a21318d354b3f3e520709230e9848ebaca8f1f514e/root`</div><div class="line"></div><div class="line">sh-4.1# docker inspect 8ab8690b07 | grep Parent</div><div class="line">        &quot;CgroupParent&quot;: &quot;&quot;,</div><div class="line">sh-4.1# docker inspect 8ab8690b07 | grep 42c75e1653</div><div class="line">    &quot;Image&quot;: &quot;42c75e16533e2ef46ffd22a21318d354b3f3e520709230e9848ebaca8f1f514e&quot;,</div><div class="line">            &quot;LowerDir&quot;: &quot;/export/lib/docker/overlay/42c75e16533e2ef46ffd22a21318d354b3f3e520709230e9848ebaca8f1f514e/root&quot;,</div><div class="line">        &quot;Image&quot;: &quot;42c75e16533e&quot;,</div><div class="line">sh-4.1#</div><div class="line"></div><div class="line">查看容器内部的存储结构：</div><div class="line">sh-4.1# ls 8ab8690b0769d07cc0b546112cfc40068d99298ed7e1857272c98a522cede527/</div><div class="line">lower-id  merged/   upper/</div><div class="line">容器的存储里面默认会存放三个文件，lower-id纪录的是image的id，也就是上面提到的LowerDir,其次存在merged和upper目录，分别为容器层，和容器最终看到的merged层。overlayfs中的lower,upper,merged三者的关系看文首。</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;overlayfs-基本概念&quot;&gt;&lt;a href=&quot;#overlayfs-基本概念&quot; class=&quot;headerlink&quot; title=&quot;overlayfs 基本概念&quot;&gt;&lt;/a&gt;overlayfs 基本概念&lt;/h3&gt;&lt;p&gt;一种联合文件系统，设计简单，速度更快。overlayfs在linux主机上只有两层，一个目录在下层，用来保存镜像(docker)，另外一个目录在上层，用来存储容器信息。在overlayfs中，底层的目录叫做lowerdir，顶层的目录称之为upperdir，对外提供统一的文件系统为merged。&lt;br&gt;当需要修改一个文件时，使用CoW将文件从只读的Lower复制到可写的Upper进行修改，结果也保存在Upper层。在Docker中，底下的只读层就是image，可写层就是Container。&lt;br&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Overlayfs" scheme="http://yoursite.com/tags/Overlayfs/"/>
    
      <category term="Storage Driver" scheme="http://yoursite.com/tags/Storage-Driver/"/>
    
  </entry>
  
  <entry>
    <title>基于PCIe体系结构的处理器结构组成</title>
    <link href="http://yoursite.com/2017/11/09/%E5%9F%BA%E4%BA%8EPCIe%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90/"/>
    <id>http://yoursite.com/2017/11/09/基于PCIe体系结构的处理器结构组成/</id>
    <published>2017-11-09T13:27:07.000Z</published>
    <updated>2017-12-20T08:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PCIe体系结构的组成部件"><a href="#PCIe体系结构的组成部件" class="headerlink" title="PCIe体系结构的组成部件"></a>PCIe体系结构的组成部件</h2><p>PCIe总线作为处理器系统的局部总线，其作用与PCI总线类似，主要目的是为了连接处理器系统中的外部设备，当然PCIe总线也可以连接其他处理器系统。<br>在大多数处理器系统中，都使用了RC、Switch和PCIe-to-PCI桥这些基本模块连接PCIe和PCI设备。在PCIe总线中，基于PCIe总线的设备，也被称为EP(Endpoint)。<br><a id="more"></a></p>
<h2 id="基于PCIe总线的通用处理器结构"><a href="#基于PCIe总线的通用处理器结构" class="headerlink" title="基于PCIe总线的通用处理器结构"></a>基于PCIe总线的通用处理器结构</h2><p>PCIe总线控制器即为RC(Root Complex).如果该处理器需要连接更多的PCIe设备时，需要使用Switch扩展PCIe链路。</p>
<p>在不同的处理器系统中，RC的实现有较大差异。PCIe总线规范并没有规定RC的实现细则。在有些处理器系统中，RC相当于PCIe主桥，也有的处理器系统也将PCIe主桥称为PCIe总线控制器。而在x86处理器系统中，RC除了包含PCIe总线控制器之外，还包含一些其他组成部件，因此RC并不等同于PCIe总线控制器。</p>
<p>如果一个RC中可以提供多个PCIe端口，这种RC也被称为多端口RC。如MPC8572处理器的RC可以直接提供3条PCIe链路，因此可以直接连接3个EP。如果MPC8572处理器需要连接更多EP时，需要使用Switch进行链路扩展。</p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/docker/nvidia-docker/%E5%9F%BA%E4%BA%8EPCIe%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84.jpg" alt=""></p>
<p>上图所示的结构将PCIe总线端口、存储器控制器等一系列与外部设备有关的接口都集成在一起，并统称为RC。RC具有一个或者多个PCIe端口，可以连接各类PCIe设备。PCIe设备包括EP(如网卡、显卡等设备)、Switch和PCIe桥。PCIe总线采用端到端的连接方式，每一个PCIe端口只能连接一个EP，当然PCIe端口也可以连接Switch进行链路扩展。通过Switch扩展出的PCIe链路可以继续挂接EP或者其他Switch。所谓的PCIe Bridge，用以将PCIe总线转换成PCI总线</p>
<p>当前4颗GPU环境的架构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$  nvidia-smi topo -m</div><div class="line">	GPU0	GPU1	GPU2	GPU3	CPU Affinity</div><div class="line">GPU0	 X 	PIX	PIX	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU1	PIX	 X 	PIX	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU2	PIX	PIX	 X 	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU3	PIX	PIX	PIX	 X 	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">Legend:</div><div class="line">  X   = Self</div><div class="line">  SOC  = Connection traversing PCIe as well as the SMP link between CPU sockets(e.g. QPI)</div><div class="line">  PHB  = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</div><div class="line">  PXB  = Connection traversing multiple PCIe switches (without traversing the PCIe Host Bridge)</div><div class="line">  PIX  = Connection traversing a single PCIe switch</div><div class="line">  NV#  = Connection traversing a bonded set of # NVLinks</div></pre></td></tr></table></figure>
<p><img src="http://oyep1jupk.bkt.clouddn.com/docker/nvidia-docker/gpu-topo.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi topo --matrix</div><div class="line"></div><div class="line">        GPU0    GPU1    GPU2    GPU3    mlx4_0  CPU Affinity</div><div class="line">GPU0     X      PIX     PHB     PHB     PHB     0-11</div><div class="line">GPU1    PIX      X      PHB     PHB     PHB     0-11</div><div class="line">GPU2    PHB     PHB      X      PIX     PHB     0-11</div><div class="line">GPU3    PHB     PHB     PIX      X      PHB     0-11</div><div class="line">mlx4_0  PHB     PHB     PHB     PHB      X </div><div class="line"></div><div class="line">Legend:</div><div class="line"></div><div class="line">  X   = Self</div><div class="line">  SOC = Path traverses a socket-level link (e.g. QPI)(CPU插槽之间直连,跨物理CPU)</div><div class="line">  PHB = Path traverses a PCIe host bridge(跨PCIe host bridge设备)</div><div class="line">  PXB = Path traverses multiple PCIe internal switches (通过内部多个Switch上进行互联的EP)</div><div class="line">  PIX = Path traverses a PCIe internal switch(同一个Switch上的EP)</div></pre></td></tr></table></figure>
<p>上面的GPU拓扑可以看出来GPU0和GPU1以及GPU2和GPU3分别处于一个<code>switch</code>和<code>PCIe host bridge</code>上，也即GPU0和GPU1(GPU2和GPU3)可以通过直连的<code>switch</code>相互通信，而GPU0和GPU2(GPU3)通信均需要经过一个<code>PCIe Host Bridge</code></p>
<p>个人理解:</p>
<ul>
<li>SOC相当于是通过物理CPU之间的SMP Link通信的(该种方式跨了CPU核心);</li>
<li>PHB相当于是通过PCIe host bridge 的PCIe设备下的EP和Switch下的EP进行互联的结构</li>
<li>PXB相当于是同一颗物理CPU下的多个Switch下的EP互联</li>
<li>PIX相当于是一个Switch内部的多个EP互相连接(效率最高)</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://www.mianbaoban.cn/blog/post/193694" target="_blank" rel="external">PCIe体系结构组成部件</a><br><a href="http://www.ssdfans.com/%E8%80%81%E7%94%B7%E5%AD%A9%E8%AF%BBpcie%E4%B9%8B%E4%BA%8C%EF%BC%9Apcie%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/" target="_blank" rel="external">PCIe拓扑结构</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;PCIe体系结构的组成部件&quot;&gt;&lt;a href=&quot;#PCIe体系结构的组成部件&quot; class=&quot;headerlink&quot; title=&quot;PCIe体系结构的组成部件&quot;&gt;&lt;/a&gt;PCIe体系结构的组成部件&lt;/h2&gt;&lt;p&gt;PCIe总线作为处理器系统的局部总线，其作用与PCI总线类似，主要目的是为了连接处理器系统中的外部设备，当然PCIe总线也可以连接其他处理器系统。&lt;br&gt;在大多数处理器系统中，都使用了RC、Switch和PCIe-to-PCI桥这些基本模块连接PCIe和PCI设备。在PCIe总线中，基于PCIe总线的设备，也被称为EP(Endpoint)。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="http://yoursite.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
      <category term="PCIe" scheme="http://yoursite.com/tags/PCIe/"/>
    
      <category term="处理器" scheme="http://yoursite.com/tags/%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>容器生态技术</title>
    <link href="http://yoursite.com/2017/11/05/%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2017/11/05/容器生态技术/</id>
    <published>2017-11-05T14:30:59.000Z</published>
    <updated>2017-11-20T06:06:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年可谓是容器云领域发展最火的一年，同时也是Kubernetes崛起的一年，那么随着容器行业的大发展，基于以Docker和Kubernetes为核心的容器生态系统也慢慢在将自己的软件体系进行解耦拆分，以实现核心功能的最优化实现。很明显的一点就是Docker在不断的拆分自己的项目，不再试图将所有容器相关技术都囊括在自己碗里，而Kubernetes则一直保持开放的态度，对接不同的第三方生态体系，也使得K8S在整个容器界内获得了良好的口碑。那么想要从事容器相关领域的技术研究或者工作，个人建议也可以将整个容器生态技术拆分，对某个要点进行深入探索，这样能够让自己更加了解容器的生态技术，也更容易在容器云生态中贡献自己的力量。</p>
<a id="more"></a>
<p>容器云生态图谱<br><img src="http://oyep1jupk.bkt.clouddn.com/container/tech/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81%E5%9B%BE%E8%B0%B1.png" alt=""></p>
<h4 id="容器引擎"><a href="#容器引擎" class="headerlink" title="容器引擎"></a>容器引擎</h4><p><a href="https://www.docker.com/" target="_blank" rel="external">Docker</a><br><a href="https://github.com/moby/moby" target="_blank" rel="external">Moby</a></p>
<p><a href="https://github.com/rkt/rkt" target="_blank" rel="external">Rkt</a></p>
<p><a href="https://github.com/lxc/lxc" target="_blank" rel="external">Lxc</a><br><a href="https://github.com/lxc/lxd" target="_blank" rel="external">Lxd</a></p>
<p><a href="https://github.com/opencontainers/runc" target="_blank" rel="external">OCI</a><br><a href="https://www.opencontainers.org/" target="_blank" rel="external">OCI官网</a></p>
<p><a href="https://github.com/hyperhq/hyperd" target="_blank" rel="external">Hyperd</a><br><a href="http://www.hypercontainer.io" target="_blank" rel="external">Hyper官网</a></p>
<h4 id="编排调度"><a href="#编排调度" class="headerlink" title="编排调度"></a>编排调度</h4><p><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="external">Kubernetes</a><br><a href="http://kubernetes.io" target="_blank" rel="external">k8s官网</a><br><a href="k8smeetup.github.io">k8s官网翻译</a><br><a href="https://www.kubernetes.org.cn/" target="_blank" rel="external">k8s中文站</a></p>
<p><a href="https://github.com/apache/mesos" target="_blank" rel="external">Mesos</a><br><a href="https://github.com/mesosphere/marathon" target="_blank" rel="external">Marathon</a></p>
<p><a href="https://github.com/docker/swarm" target="_blank" rel="external">Swarm</a></p>
<p><a href="https://github.com/rancher/rancher" target="_blank" rel="external">Rancher</a></p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><h5 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h5><p><a href="https://github.com/containernetworking/cni" target="_blank" rel="external">CNI</a></p>
<p><a href="https://github.com/projectcalico/calico" target="_blank" rel="external">Calico</a><br><a href="https://www.projectcalico.org/" target="_blank" rel="external">Calico官网</a></p>
<p><a href="https://github.com/weaveworks/weave" target="_blank" rel="external">Weave</a><br><a href="https://www.weave.works" target="_blank" rel="external">Weave官网</a></p>
<p><a href="https://github.com/contiv/netplugin" target="_blank" rel="external">Contiv</a><br><a href="http://contiv.io" target="_blank" rel="external">Contiv官网</a></p>
<p><a href="https://github.com/openvswitch/ovs" target="_blank" rel="external">ovs</a><br><a href="http://openvswitch.org/" target="_blank" rel="external">ovs官网</a></p>
<h5 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a>CNM</h5><p><a href="https://github.com/docker/libnetwork" target="_blank" rel="external">libnetwork</a></p>
<p><a href="https://github.com/projectcalico/libnetwork-plugin" target="_blank" rel="external">Calico-libnetwork</a></p>
<p><a href="https://github.com/contiv/netplugin" target="_blank" rel="external">Contiv</a></p>
<p><a href="https://github.com/weaveworks/weave" target="_blank" rel="external">Weave</a></p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p><a href="https://github.com/ceph/ceph" target="_blank" rel="external">Ceph</a></p>
<p><a href="https://github.com/gluster/glusterfs" target="_blank" rel="external">GlusterFS</a></p>
<p><a href="https://github.com/ipdcode/containerfs" target="_blank" rel="external">ContainerFS</a></p>
<p><a href="https://github.com/coreos/torus" target="_blank" rel="external">Torus</a></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="external">ElasticSearch</a></p>
<p><a href="https://github.com/elastic/beats" target="_blank" rel="external">Filebeat</a></p>
<p><a href="https://github.com/fluent/fluentd" target="_blank" rel="external">Fluentd</a><br><a href="http://www.fluentd.org/" target="_blank" rel="external">Fluentd官网</a></p>
<p><a href="https://github.com/elastic/logstash" target="_blank" rel="external">Logstash</a></p>
<p><a href="https://github.com/elastic/kibana" target="_blank" rel="external">Kibana</a></p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><h5 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h5><p><a href="https://github.com/influxdata/telegraf" target="_blank" rel="external">Telegraf</a></p>
<p><a href="https://github.com/firehol/netdata" target="_blank" rel="external">Netdata</a><br><a href="https://my-netdata.io/" target="_blank" rel="external">Netdata官网</a></p>
<p><a href="https://github.com/google/cadvisor" target="_blank" rel="external">cAdivisor</a></p>
<p><a href="https://github.com/kubernetes/heapster" target="_blank" rel="external">Heapster</a></p>
<p><a href="https://github.com/prometheus/prometheus" target="_blank" rel="external">Prometheus</a></p>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p><a href="https://github.com/influxdata/influxdb" target="_blank" rel="external">Influxdb</a></p>
<p><a href="https://github.com/OpenTSDB/opentsdb" target="_blank" rel="external">OpenTSDB</a></p>
<h4 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h4><p><a href="https://github.com/grafana/grafana" target="_blank" rel="external">Grafana</a><br><a href="https://grafana.com" target="_blank" rel="external">Grafana官网</a></p>
<h3 id="镜像存储和安全"><a href="#镜像存储和安全" class="headerlink" title="镜像存储和安全"></a>镜像存储和安全</h3><h4 id="镜像存储"><a href="#镜像存储" class="headerlink" title="镜像存储"></a>镜像存储</h4><p><a href="https://github.com/vmware/harbor" target="_blank" rel="external">Harbor</a></p>
<p><a href="https://github.com/jcloudpub/speedy" target="_blank" rel="external">Speedy</a></p>
<h4 id="安全扫描"><a href="#安全扫描" class="headerlink" title="安全扫描"></a>安全扫描</h4><p><a href="https://github.com/coreos/clair" target="_blank" rel="external">Clair</a></p>
<p><a href="https://github.com/future-architect/vuls" target="_blank" rel="external">Vuls</a></p>
<h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p><a href="">bind</a><br><a href="https://github.com/coredns/coredns" target="_blank" rel="external">coredns</a><br><a href="">skydns</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年可谓是容器云领域发展最火的一年，同时也是Kubernetes崛起的一年，那么随着容器行业的大发展，基于以Docker和Kubernetes为核心的容器生态系统也慢慢在将自己的软件体系进行解耦拆分，以实现核心功能的最优化实现。很明显的一点就是Docker在不断的拆分自己的项目，不再试图将所有容器相关技术都囊括在自己碗里，而Kubernetes则一直保持开放的态度，对接不同的第三方生态体系，也使得K8S在整个容器界内获得了良好的口碑。那么想要从事容器相关领域的技术研究或者工作，个人建议也可以将整个容器生态技术拆分，对某个要点进行深入探索，这样能够让自己更加了解容器的生态技术，也更容易在容器云生态中贡献自己的力量。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
      <category term="容器生态" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>我的越野元年</title>
    <link href="http://yoursite.com/2017/11/05/%E6%88%91%E7%9A%84%E8%B6%8A%E9%87%8E%E5%85%83%E5%B9%B4/"/>
    <id>http://yoursite.com/2017/11/05/我的越野元年/</id>
    <published>2017-11-05T10:35:33.000Z</published>
    <updated>2017-11-05T13:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>时间过的很快，不知不觉中已经到了一年的最后两个月了，而同样也到了需要供暖和剁手的季节(插播个小广告:挑好物，上京东哦！)。北京的秋天和冬天其实并不明显，因为天气逐渐变冷，我也深知，今年的户外长跑可能就要止步于昨天的”奥森100+超级马拉松”的陪跑活动了，该赛事由”汇跑赛事”主办，参赛选手需要有资深的跑步经历，并且需要再12小时内完成100+公里的马拉松。很幸运，公司的同事”藤神”也是其中50多位选手中的一员，而我为了感受”疯(封)神之旅”，也依然加入了”藤神”陪跑团中，助力京东跑团的兄弟安全完赛。</p>
<a id="more"></a>
<h4 id="2017马拉松赛事历程"><a href="#2017马拉松赛事历程" class="headerlink" title="2017马拉松赛事历程"></a>2017马拉松赛事历程</h4><p><strong>11-4 奥森100+超级马拉松</strong><br>封神之路需要一个强大的跑团作为支撑，作为“藤神”的后盾，我们也有一只团结、温暖、强大的跑团。<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/aosen100-3.jpeg" alt=""></p>
<p>跑步过程中的临时补给拉伸，再次整装待发。<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/aosen100.jpeg" alt=""></p>
<p>终于在12个小时内轻松完赛。<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/aosen100-1.jpeg" alt=""></p>
<p>对了，中间戴红帽子的就是我们这次比赛的主将”藤神”</p>
<p>由于我是最后陪跑的，也没在后方给”藤神”太多的帮助，所以在最后三十公里，决定都陪着”藤神”跑，虽然最后一圈半比较冷，但陪跑的过程中却是无比开心和自豪，其实也是想趁着这次机会，再来一次长跑。<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/aosen100-2.png" alt=""></p>
<p>“藤神”封神之路，在我看来尽是感动，三四十位跑友们自发组成陪跑团，提供补给，路跑开路，全程护送到终点，大家没有明确分工，但却各司其职，尽自己的最大努力来给主将兄弟助威。这一方面是因为跑友情，另外一方面可能也是因为”京东跑团”情，让我再一次感受到”京东跑团、爱心暖暖！”。也许如果哪天我离开京东了，可能最让我不舍的就是京东跑团这个民间组织以及跑团的各位兄弟了吧。</p>
<p>再回退两个月，9月参加了两次长跑，分别是“2017北京马拉松”和“2017太原马拉松”。讲真，跑步六七年，我还未曾跑过超过30KM的距离，一方面是因为懒癌上身，独自一人懒得跑那么多，另外一方面是因为不够跑🐴的资格，导致多次报名马拉松都未中签，所以，在得知一个月要参加两次马拉松的时候，内心的愉悦是难以言表的，而且最终两场比赛都安全完赛且刷新个人成绩，这其中也是非常感谢京东跑团的各位兄弟姐妹们特别是我们的跑团老大哥团长凯哥，我和凯哥配速相当，这一两年只要有比赛，基本都会一起跑，在凯哥的帮助指导下飞速进步，而凯哥作为一位长辈在我的成长之路上也影响了我很多，肉麻的话我就不说了，哈哈。</p>
<p><strong>9-17 北京马拉松</strong><br>起跑前在天安门前的齐唱国歌:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima1.jpeg" alt=""></p>
<p>起点的人山人海:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima2.jpeg" alt=""></p>
<p>起跑前的跑团合影:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima8.jpeg" alt=""></p>
<p>快到终点时的欣喜:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima10.jpeg" alt=""></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima11.jpeg" alt=""></p>
<p>帅气的北马完赛奖牌:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima5.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima6.jpeg" alt=""></p>
<p>完赛大合照:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima7.jpeg" alt=""></p>
<p>北马路线和完赛证书:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima3.png" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/beima9.png" alt=""></p>
<p>北马，我的第二个全程马拉松，成功在四小时三十分钟内完赛，在我的两次马拉松历史中刷新了最佳成绩。</p>
<p><strong>9-10 太马前的跑团</strong><br>跑前合影<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima1.jpeg" alt=""></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima4.jpeg" alt=""><br>自左向右分别是：+神、我、凯哥、磊哥、藤神、爱林和妹妹的钧涵小姐姐</p>
<p>桥洞下的人山人海<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima2.jpeg" alt=""></p>
<p>英姿飒爽的跑者(左边那位帅气的男子就是凯哥)<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima6.jpeg" alt=""></p>
<p>晒奖牌<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima5.jpeg" alt=""></p>
<p>太马路线和完赛证书:<br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima3.png" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/malasong/taima7.png" alt=""></p>
<p><strong>崇礼50越野</strong><br>再往回倒一两个月，具体时间忘记了，是去崇礼参加的50KM越野比赛，算是第三次参加超过全马距离的越野赛事，这次我的好搭档凯哥由于身体原因不能参赛，没有相当配速的跑友一起，我需要更加小心和合理规划自己的时间和体力。</p>
<p>越野跑者装备<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli1.jpeg" alt=""><br>(突然发现，越野真的很费钱，很入门很简单的装备至少也在一两千块了，心疼几秒)</p>
<p>赛前合影<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli6.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli3.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli5.jpeg" alt=""></p>
<p>崇礼山上的美景<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli4.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli7.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli8.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli16.jpeg" alt=""></p>
<p>离天空最近的地方<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli10.jpeg" alt=""></p>
<p>英姿飒爽<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli11.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli13.jpeg" alt=""></p>
<p>妹子帮忙做的后期,很符合我的口味<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli14.jpeg" alt=""></p>
<p>崇礼50路线<br><img src="http://oyep1jupk.bkt.clouddn.com/running/chongli50/chongli15.jpeg" alt=""></p>
<p><strong>TNF50赛事</strong><br>再往前两个多月，应该四月多，独自参加了碎碎念的北京TNF50公里越野，这次依然是没有配速相当的跑友，并且是晚上凌晨起跑，对于这次比赛的心情更是无以言表，但与此同时又需要更加的小心。</p>
<p>TNF宣传牌<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf1.jpeg" alt=""></p>
<p>起跑前的留念<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf2.jpeg" alt=""></p>
<p>TNF50起跑现场<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf3.jpeg" alt=""></p>
<p>香山夜景<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf4.jpeg" alt=""></p>
<p>清晨到达CP9<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf5.jpeg" alt=""></p>
<p>清晨的水库(忘记名字了，之前跑过的路线)<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf6.jpeg" alt=""></p>
<p>爬山路<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf7.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf8.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf9.jpeg" alt=""></p>
<p>完赛路线和奖牌<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf10.png" alt=""></p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf11.jpeg" alt=""></p>
<p>完赛留念<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf15.jpeg" alt=""></p>
<p>可怜的脚丫子<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf13.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf12.jpeg" alt=""></p>
<p>唯一的抓拍照<br><img src="http://oyep1jupk.bkt.clouddn.com/running/tnf50/tnf14.jpeg" alt=""></p>
<p><strong>新年刷天安门跑</strong><br>再上一次户外长跑应该就是元旦时和几位兄弟姐妹们一起刷天安门了，只为了留作一些纪念，新年伊始刷个新年的数字希望也能重新开始。到目前为止，我已经刷过2015,2016,2017三个数字了，等待明年碰个好天气一起刷2018.</p>
<p><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/2017-1.jpeg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/2017.jpeg" alt=""></p>
<p><strong>青芝坞越野</strong></p>
<p>青芝坞越野赛算是我真正意义上第一个长距离越野赛事，是2016年11月初和凯哥一起去杭州参赛的，也正是因为那场赛事的成功完赛，让我有了底气去参加今年的两场50公里的越野赛事。</p>
<p>青芝坞越野赛照<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/qingzhiwu.jpeg" alt=""></p>
<p>帅气的奖牌<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/qingzhiwu2.jpeg" alt=""></p>
<p>完赛路线<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/qingzhiwu3.jpeg" alt=""></p>
<p><strong>与越野结缘</strong></p>
<p>与越野结缘，应当算是京东体育主办的”西山7公里轻越野”，但是轻的让人感觉不到有什么难度，但也是那次体验让我真正喜欢上了越野赛事。</p>
<p>京东跑团的多位跑友一同参加，欢聚一堂<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/qyueye1.jpg" alt=""><br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/qyueye2.jpg" alt=""></p>
<p>真的非常感谢京东跑团的兄弟们，一路上有这么多志同道合的朋友们一起坚持一起跑下来！</p>
<p>结缘后的日子，很快便和凯哥组成越野小分队初试半程越野赛<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/jingxigudao.jpg" alt=""></p>
<p>青涩的少年<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/jingxigudao2.jpg" alt=""></p>
<h4 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h4><p>从接触越野到目前为止一年多，去年是在接触并熟悉感受越野，今年则是在越野赛中不断认识自己，而今年也是我的越野元年，明年我可能回去挑战一些越野赛事并且去尝试感受不同地方的风景和山脉，希望自己能够在越野赛事中不断的认识自己，历练自己。</p>
<p>大连100的🏆很帅气，我想明年肯定会去体验一下的。<br><img src="http://oyep1jupk.bkt.clouddn.com/running/2017/dalian100.jpg" alt=""></p>
<p>越野、马拉松，2018 我们再见！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间过的很快，不知不觉中已经到了一年的最后两个月了，而同样也到了需要供暖和剁手的季节(插播个小广告:挑好物，上京东哦！)。北京的秋天和冬天其实并不明显，因为天气逐渐变冷，我也深知，今年的户外长跑可能就要止步于昨天的”奥森100+超级马拉松”的陪跑活动了，该赛事由”汇跑赛事”主办，参赛选手需要有资深的跑步经历，并且需要再12小时内完成100+公里的马拉松。很幸运，公司的同事”藤神”也是其中50多位选手中的一员，而我为了感受”疯(封)神之旅”，也依然加入了”藤神”陪跑团中，助力京东跑团的兄弟安全完赛。&lt;/p&gt;
    
    </summary>
    
      <category term="生活思考" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB%E6%80%9D%E8%80%83/"/>
    
    
      <category term="跑步" scheme="http://yoursite.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
      <category term="马拉松" scheme="http://yoursite.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
      <category term="越野" scheme="http://yoursite.com/tags/%E8%B6%8A%E9%87%8E/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker镜像快速启动Etcd集群</title>
    <link href="http://yoursite.com/2017/11/03/%E4%BD%BF%E7%94%A8Docker%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8Etcd%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2017/11/03/使用Docker镜像快速启动Etcd集群/</id>
    <published>2017-11-03T01:11:57.000Z</published>
    <updated>2017-11-05T02:00:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章上接<a href="https://xxbandy.github.io/2017/08/26/Dockerfile-etcd/" target="_blank" rel="external">自构建etcd镜像</a>来使用systemd工具利用自构建的etcd镜像快速的搭建一套高可用的etcd集群。</p>
<a id="more"></a>
<h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><p>测试集群使用3节点的etcd集群进行搭建测试，以下为node1节点配置示例，其他两个节点类似，仅需要修改<code>NAME</code><br><a href="http://blog.csdn.net/peterxiaoq/article/details/72831866" target="_blank" rel="external">systemd添加自定义服务</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"># cat /etc/etcd/etcd.conf</div><div class="line">NAME=&quot;etcd-1&quot;</div><div class="line">DATADIR=&quot;/export/etcd_data&quot;</div><div class="line">MYHOST=&quot;http://10.0.0.1&quot;</div><div class="line">PORT=&quot;2379&quot;</div><div class="line">CLUSTER_PORT=&quot;2380&quot;</div><div class="line">CLUSTER=&quot;etcd-1=http://10.0.0.1:2380,etcd-2=http://10.0.0.2:2380,etcd-3=http://10.0.0.3:2380&quot;</div><div class="line">CLUSTER_TOKEN=&quot;my-etcd-token&quot;</div><div class="line">CLUSTER_STATE=&quot;new&quot;</div><div class="line"></div><div class="line"># cat /etc/systemd/system/etcd-node.service</div><div class="line">[Unit]</div><div class="line">Description=etcd node</div><div class="line">After=docker.service</div><div class="line">Requires=docker.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">User=root</div><div class="line">EnvironmentFile=-/etc/etcd/etcd.conf</div><div class="line">PermissionsStartOnly=true</div><div class="line">ExecStart=/usr/bin/docker run -itd --net=host   --name=etcd-node -e NAME=$&#123;NAME&#125; -e DATADIR=$&#123;DATADIR&#125; -e MYHOST=$&#123;MYHOST&#125; -e PORT=$&#123;PORT&#125; -e CLUSTER_PORT$=$&#123;CLUSTER_PORT&#125; -e CLUSTER=$&#123;CLUSTER&#125; -e CLUSTER_TOKEN=$&#123;CLUSTER_TOKEN&#125; -e CLUSTER_STATE=$&#123;CLUSTER_STATE&#125; xxbandy123/etcd:3.0.10</div><div class="line"></div><div class="line">#ExecStop=/usr/bin/docker rm -f etcd-node</div><div class="line">#Restart=always</div><div class="line">#RestartSec=10</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div></pre></td></tr></table></figure></p>
<p><code>注意1</code>:需要分别修改每个节点上/etc/etcd/etcd.conf配置文件中的NAME和MYHOST、CLUSTER三个变量<br><code>注意2</code>:在编写systemctl服务管理配置的时候，一定不要设置重启策略并且设置<code>ExecStop</code>,因为初始化集群时需要多个节点同时进行启动并互相发现，当重启某个实例的时候，重新选举注册时，就会发现该节点已经存在与集群中，因此无法正常加入集群，而导致实例启动失败。正常的做法应该是某个实例异常后，先在集群内部摘除该节点，其后将该节点按照当前状态加入到集群后根据相关信息再次启动实例<br><a href="https://segmentfault.com/a/1190000003976539" target="_blank" rel="external">etcd运维</a></p>
<h3 id="启动验证"><a href="#启动验证" class="headerlink" title="启动验证"></a>启动验证</h3><p>分别启动三个docker实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload</div><div class="line">systemctl start etcd-node</div><div class="line"></div><div class="line"># etcdctl cluster-health</div><div class="line">2017-11-03 09:15:49.006358 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-11-03 09:15:49.007093 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 911c5e15a35cdb8f is healthy: got healthy result from http://10.0.0.1:2379</div><div class="line">member b01d138087dbe547 is healthy: got healthy result from http://10.0.0.3:2379</div><div class="line">member c22c1c7b5a4c9f9b is healthy: got healthy result from http://10.0.0.2:2379</div><div class="line">cluster is healthy</div></pre></td></tr></table></figure>
<h3 id="集群维护"><a href="#集群维护" class="headerlink" title="集群维护"></a>集群维护</h3><p>模拟集群某个节点宕机，并恢复集群</p>
<h4 id="查看当前集群状态信息以及可用性"><a href="#查看当前集群状态信息以及可用性" class="headerlink" title="查看当前集群状态信息以及可用性"></a>查看当前集群状态信息以及可用性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">etcdctl member list</div><div class="line">2017-11-04 09:04:14.150103 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">9923f8b86d3ce7a6: name=etcd-1 peerURLs=http://10.0.0.1:2380 clientURLs=http://172.25.44.6:2379 isLeader=false</div><div class="line">b01d138087dbe547: name=etcd-3 peerURLs=http://10.0.0.3:2380 clientURLs=http://172.25.47.78:2379 isLeader=false</div><div class="line">c22c1c7b5a4c9f9b: name=etcd-2 peerURLs=http://10.0.0.2:2380 clientURLs=http://172.25.47.77:2379 isLeader=true</div><div class="line">[root@hc-25-44-6 pe]# etcdctl set bgops biaoge</div><div class="line">2017-11-04 09:04:40.234434 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">biaoge</div><div class="line"></div><div class="line"># etcdctl get bgops</div><div class="line">2017-11-04 09:05:22.059435 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">biaoge</div></pre></td></tr></table></figure>
<h4 id="删除node2节点上的容器实例"><a href="#删除node2节点上的容器实例" class="headerlink" title="删除node2节点上的容器实例"></a>删除node2节点上的容器实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># docker rm -f -v etcd-node</div><div class="line"># etcdctl cluster-health</div><div class="line">member 9923f8b86d3ce7a6 is healthy: got healthy result from http://10.0.0.1:2379</div><div class="line">member b01d138087dbe547 is healthy: got healthy result from http://10.0.0.3:2379</div><div class="line">failed to check the health of member c22c1c7b5a4c9f9b on http://10.0.0.2:2379: Get http://172.25.47.77:2379/health: dial tcp 172.25.47.77:2379: getsockopt: connection refused</div><div class="line">member c22c1c7b5a4c9f9b is unreachable: [http://10.0.0.2:2379] are all unreachable</div><div class="line">cluster is healthy</div><div class="line"></div><div class="line"># etcdctl get bgops</div><div class="line">2017-11-04 09:10:40.658013 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">biaoge</div></pre></td></tr></table></figure>
<p>如上显示，其中node2节点的已经失联，而由于当前etcd集群是3实例集群，因此集群整体仍然是健康状态，并且能够正常使用</p>
<h4 id="恢复node2节点实例到集群中"><a href="#恢复node2节点实例到集群中" class="headerlink" title="恢复node2节点实例到集群中"></a>恢复node2节点实例到集群中</h4><p>注意：如果单纯的去按照原始配置启动node2上的实例的话，会提示无法加入集群(因为实例id已经注册上去了c22c1c7b5a4c9f9b)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># docker logs etcd-node</div><div class="line"> ....</div><div class="line">2017-11-04 01:12:25.307452 C | etcdmain: member c22c1c7b5a4c9f9b has already been bootstrapped</div></pre></td></tr></table></figure></p>
<p>正确的恢复姿势<br>1.在集群中移除异常节点<br>2.在集群中增加集群节点(异常节点也作为新节点加入集群)<br>3.根据集群反馈信息进行异常节点重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># etcdctl member remove c22c1c7b5a4c9f9b</div><div class="line">2017-11-04 09:15:48.488427 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">Removed member c22c1c7b5a4c9f9b from cluster</div><div class="line"></div><div class="line"># etcdctl member add etcd-2 http://10.0.0.2:2380</div><div class="line">2017-11-04 09:16:50.704247 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">Added member named etcd-2 with ID 51e807366fadaded to cluster</div><div class="line"></div><div class="line">ETCD_NAME=&quot;etcd-2&quot;</div><div class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-2=http://10.0.0.2:2380,etcd-1=http://10.0.0.1:2380,etcd-3=http://10.0.0.3:2380&quot;</div><div class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;existing&quot;</div></pre></td></tr></table></figure></p>
<p>根据反馈信息进行异常节点恢复(给出了name,cluster,state三个参数)<br>由于我们是根据原有集群进行恢复节点，所以需要修改node2节点的状态,并启动实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># grep STATE  /etc/etcd/etcd.conf</div><div class="line">CLUSTER_STATE=&quot;existing&quot;</div><div class="line"># systemctl restart  etcd-node</div><div class="line"># docker ps</div><div class="line">CONTAINER ID        IMAGE                               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">9fb8b1544642        xxbandy123/etcd:3.0.10   &quot;/docker-entrypoint.s&quot;   33 seconds ago      Up 32 seconds                           etcd-node</div><div class="line"></div><div class="line"># etcdctl cluster-health</div><div class="line">2017-11-04 09:23:44.053605 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-11-04 09:23:44.054497 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 51e807366fadaded is healthy: got healthy result from http://10.0.0.2:2379</div><div class="line">member 9923f8b86d3ce7a6 is healthy: got healthy result from http://10.0.0.1:2379</div><div class="line">member b01d138087dbe547 is healthy: got healthy result from http://10.0.0.3:2379</div><div class="line">cluster is healthy</div><div class="line"># etcdctl get bgops</div><div class="line">2017-11-04 09:23:38.541355 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">biaoge</div></pre></td></tr></table></figure></p>
<p>至此，node2节点成功恢复到etcd集群中，并可以提供正常服务</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章上接&lt;a href=&quot;https://xxbandy.github.io/2017/08/26/Dockerfile-etcd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;自构建etcd镜像&lt;/a&gt;来使用systemd工具利用自构建的etcd镜像快速的搭建一套高可用的etcd集群。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Etcd-Cluster" scheme="http://yoursite.com/tags/Etcd-Cluster/"/>
    
      <category term="systemd" scheme="http://yoursite.com/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>玩转Docker运维管理</title>
    <link href="http://yoursite.com/2017/10/30/%E7%8E%A9%E8%BD%ACDocker%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2017/10/30/玩转Docker运维管理/</id>
    <published>2017-10-30T14:41:34.000Z</published>
    <updated>2017-10-30T14:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在使用docker过程中，我们经常发现管理维护是一个很复杂过程，因为我们在使用docker commands的过程中，我们只会去使用我们认为简单并且熟悉的命令，然而docker本身其实是提供给我们很多便捷且人性化的工具的，如果掌握这些使用技巧，也许你的维护管理工作将会事半功倍，并且给人看起来会很牛逼的样子。</p>
</blockquote>
<a id="more"></a>
<h4 id="创建容器时传入环境变量"><a href="#创建容器时传入环境变量" class="headerlink" title="创建容器时传入环境变量"></a>创建容器时传入环境变量</h4><p>在实际应用场景中，不论是从安全还是可配置方面去考虑，很多参数是比较适合用环境变量加载进去的，比如数据库的连接信息，时区，还有字体支持等等，在创建容器的时候其实都可以使用-e 指定key/value进行传递环境变量进去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; biaoge/centos6.8-jdjr-test-app </div><div class="line">ee20b44301e27c16eae63dab243d293054178dd5f819c23d44bd9e534208bb42</div><div class="line">sh-4.2# docker exec -it test-env date</div><div class="line">2017年 01月 17日 星期二 10:35:17 CST</div><div class="line">sh-4.2# date</div><div class="line">Tue Jan 17 10:35:21 CST 2017</div><div class="line">可以看到加了时区环境变量的容器已经和宿主机在同一个时区(CST)，并且时间和宿主机基本同步</div><div class="line"></div><div class="line">sh-4.2# docker run -itd --name test  biaoge/centos6.8-jdjr-test-app</div><div class="line">d6a02874b999ff4eea79e3b302148b42043af01c89a5d31e5d858e0806f9077a</div><div class="line">sh-4.2# docker exec -it test date</div><div class="line">2017年 01月 20日 星期五 01:43:48 Asia</div><div class="line">默认没有加时区环境变量的容器还是Asia</div></pre></td></tr></table></figure>
<h4 id="调整宿主机和容器的时间差异"><a href="#调整宿主机和容器的时间差异" class="headerlink" title="调整宿主机和容器的时间差异"></a>调整宿主机和容器的时间差异</h4><p>首先我们需要弄清几个概念：在类unix系统中有硬件时钟与系统时钟，硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟，系统时钟则是指kernel中的时钟。unix以及linux系统时间是从格林威治时间到当前的秒数，即1970年1月1日凌晨零点零分零秒到当前的时间，全球都一样，这是绝对值；而时区则是由于地理位置差异、行政区划导致各地显示时间的差异，为了克服时间上的混乱，规定将全球划分为24个时区，我们国家属于东八区标识为CST。</p>
<p>因此，对于 Docker 容器而言，根本不存在宿主和容器的时间差异问题，因为他们使用的是同一个内核、同一个时钟，二者完全一样，所以根本不存在同步问题。一般来说这个问题是由时区导致的，可以使用date命令查看下容器当前的时间时区是啥。UTC(通用协调时)表示使用的是国际标准0时区，UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。CST表示中国标准时间时区一般是中国上海”Aisa/Shanghai”，也就是说UTC和CST相差了8个小时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">解决办法：</div><div class="line">创建容器的时候，使用-e 将时区信息传入到容器内部。</div><div class="line">sh-4.2# docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; images</div></pre></td></tr></table></figure>
<p><code>注意：其实使用单纯的环境变量来改变容器内部的TIME ZONE，只会影响当前容器用户的时区，一旦切换到真正的root用户就会发现时区依然是不正确的，比如以下栗子：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd --name test-env -e TZ=&apos;Asia/Shanghai&apos; images</div><div class="line">$ docker exec -it test-env bash</div><div class="line">bash-4.1# date</div><div class="line">2017年 09月 20日 星期三 20:45:54 CST</div><div class="line">bash-4.1# sudo su -c date</div><div class="line">2017年 09月 20日 星期三 08:46:02 EDT</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<p>那么如何真正解决时区这个问题呢？其实是<code>/etc/localtime</code>在作怪，用户只需要将容器内部的localtime改成你想要的时区就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bash-4.1# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </div><div class="line">bash-4.1# date</div><div class="line">2017年 09月 20日 星期三 20:54:35 CST</div><div class="line">bash-4.1# sudo su -c date</div><div class="line">2017年 09月 20日 星期三 20:54:39 CST</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<p>So,在使用Dockerfile构建镜像的时候将<code>/usr/share/zoneinfo/Asia/Shanghai</code>强制软连接到<code>/etc/localtime</code>就可以永久修复时区的问题了。</p>
<p>####指定容器的rootfs的大小<br>在使用docker的过程中，会发现cpu和memory可以很随意的动态调整，但是默认的rootfs却是不能随意调整的，默认是10g大小，当然如果对于数据有需求，可以通过挂载voulme进行扩展存储。如果用户执意想要调整rootfs的大小，在docker1.12版本默认提供了两种方式：在启动docker 的时候加载参数<code>--storage-opt dm.basesize=40G</code>用来调整默认容器的rootfs大小；在创建容器的时候使用参数<code>--storage-opt size=70G</code>来设置改容器的rootfs大小。</p>
<p><code>喜讯：在docker最近发布的1.13版本中，支持了磁盘的配额，不过还未测试</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name volume-test --storage-opt size=70G biaoge/centos6.8-jdjr-test-app</div><div class="line">18d47e69802aa84df00182885b256c50ebc56e15d8e6990fc1e187ffe254171e</div><div class="line"></div><div class="line">sh-4.2# docker exec -it volume-test df -H | grep rootfs</div><div class="line">rootfs                 76G  1.5G   74G   2% /</div><div class="line">sh-4.2# docker exec -it test-env df -H | grep rootfs</div><div class="line">rootfs                 11G  1.5G  9.3G  14% /</div></pre></td></tr></table></figure>
<h4 id="快速管理容器和镜像"><a href="#快速管理容器和镜像" class="headerlink" title="快速管理容器和镜像"></a>快速管理容器和镜像</h4><p>在docker中删除容器需要指定容器名或者容器id，但是在容器比较多，并且状态不一的情况下删除容器还是需要走下心的。不过好处是docker ps默认提供了很多好用的功能，可以很方便地管理容器(创建容器的时候如果加上label后更方便哦)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">原理：先用docker ps -a -q 输出所有容器的container id(-f 表示过滤参数或者输出格式)，然后作为docker rm 的参数进行批量删除</div><div class="line">输出所有容器的name(利用了Golang语言中的模板语法)：</div><div class="line">sh-4.2# docker ps --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">test-env</div><div class="line">test-args</div><div class="line">test-run</div><div class="line">输出所有容器名包含test的容器，并打印容器名</div><div class="line">sh-4.2# docker ps -f name=test --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">test-env</div><div class="line">test-args</div><div class="line">test-run</div><div class="line">查看退出状态的容器，并打印容器名</div><div class="line">sh-4.2# docker ps -f status=exited --format=&quot;&#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">thirsty_brahmagupta</div><div class="line">clever_mestorf</div><div class="line">hopeful_morse</div><div class="line">stoic_morse</div><div class="line">elated_williams</div><div class="line">tender_jepsen</div><div class="line">reverent_mirzakhani</div><div class="line"></div><div class="line">删除所有容器：</div><div class="line">sh-4.2# docker rm -f -v $(docker ps -a -q)</div><div class="line">删除/启动所有退出的容器：</div><div class="line">sh-4.2# docker rm/start $(docker ps -qf status=exited)</div><div class="line">删除所有镜像：</div><div class="line">sh-4.2# docker rmi $(docker images -q)</div><div class="line"></div><div class="line">查看悬挂镜像:</div><div class="line">sh-4.1# docker  images -qf dangling=true</div><div class="line"></div><div class="line">只查看镜像或者容器指定的信息(在docker1.10之后才支持的)</div><div class="line"></div><div class="line">只列出镜像的id以及仓库名称：</div><div class="line">sh-4.2# docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</div><div class="line">67591570dd29: centos</div><div class="line">0a18f1c0ead2: rancher/server</div><div class="line"></div><div class="line">只列出容器的相关id,image,status和name</div><div class="line">sh-4.2# docker ps --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Image&#125;&#125; : &#123;&#123;.Status&#125;&#125; : &#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">66b60b72f00e: centos : Up 7 days : pensive_poincare</div><div class="line">或者自己重新定义列,就和原生差不多:</div><div class="line">sh-4.2# docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</div><div class="line">CONTAINER ID        IMAGE                                         STATUS              NAMES</div><div class="line">66b60b72f00e        centos                                        Up 7 days           pensive_poincare</div></pre></td></tr></table></figure>
<p><code>注意:</code>其实上面的–format利用的就是go语言中的模版语法，所有容器的组织信息都在结构体中：</p>
<p><code>*formatter.containerContext</code></p>
<h4 id="容器label的使用"><a href="#容器label的使用" class="headerlink" title="容器label的使用"></a>容器label的使用</h4><p>在实际运维过程中，大量的容器可能会一些运维上的挑战，通过使用label，可以很好的将容器分类。label贯穿于docker的整个过程。<br>这个label可以作为你区分业务，区分模板各种区分容器的标识，通过标识，可以将容器更好的进行分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sh-4.2# docker run -itd --name volume-test --storage-opt size=70G --label zone=test biaoge/centos6.8-jdjr-test-app</div><div class="line">c3772397e58e663095c2c0fd8d688b3d41b494097999ec2b6d6b7c509d23a138</div><div class="line">创建容器的时候定义一个label，表示该容器在test这个区域</div><div class="line">使用定义的label进行快速检索容器，并进行下一步操作(比如删除啦，更新啦)</div><div class="line">sh-4.2# docker ps -qf label=zone=test</div><div class="line">c3772397e58e</div><div class="line">sh-4.2# docker ps -f label=zone=test --format=&apos;&#123;&#123;.Names&#125;&#125;&apos;</div><div class="line">volume-test</div></pre></td></tr></table></figure>
<h4 id="快速查看容器的相关配置信息"><a href="#快速查看容器的相关配置信息" class="headerlink" title="快速查看容器的相关配置信息"></a>快速查看容器的相关配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">查看容器的devicemapper设备：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.GraphDriver.Data.DeviceName&#125;&#125;&apos; nginx </div><div class="line">docker-8:1-67411759-7c9d6d3327b02659c81bcb70bf6a4c7a45df6a589af2a2d42a387dc0e90d4913</div><div class="line">查看容器的PID：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.State.Pid&#125;&#125;&apos; nginx </div><div class="line">27521</div><div class="line">查看容器name：</div><div class="line">sh-4.2# docker inspect -f &apos;&#123;&#123;.Name&#125;&#125;&apos; nginx </div><div class="line">/nginx</div><div class="line">获取容器的ID：</div><div class="line">sh-4.2# docker inspect --format &#123;&#123;.Id&#125;&#125; nginx</div><div class="line">53214bc9cd001f2c548edcce0c42fe51f1a118c08941406d43122a8348055843</div></pre></td></tr></table></figure>
<h4 id="使用alias来预定义常用的命令"><a href="#使用alias来预定义常用的命令" class="headerlink" title="使用alias来预定义常用的命令"></a>使用alias来预定义常用的命令</h4><p>docker管理命令经常需要指定各种参数，通过linux的alias命令将默认的参数预定义起来，可以很方便的进行管理容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">sh-4.2# alias dockerrm=&apos;docker rm -f -v&apos;</div><div class="line">sh-4.2# alias dockerexec=&apos;docker exec -it&apos;</div><div class="line">sh-4.2# alias dockerrmimage=&apos;docker rmi&apos;</div><div class="line"></div><div class="line">sh-4.2# dockerrm volume-test</div><div class="line">volume-test</div><div class="line"></div><div class="line">sh-4.2# dockerexec volume-test ls</div><div class="line">bin   dev  export  lib	  media  opt   root  selinux  sys  usr</div><div class="line">boot  etc  home    lib64  mnt	 proc  sbin  srv      tmp  var</div><div class="line">sh-4.2# dockerexec volume-test bash</div><div class="line">bash-4.1#</div></pre></td></tr></table></figure>
<h4 id="使容器随着docker-daemon的启动一同启动"><a href="#使容器随着docker-daemon的启动一同启动" class="headerlink" title="使容器随着docker daemon的启动一同启动"></a>使容器随着docker daemon的启动一同启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run 的时候加参数--restart=always</div></pre></td></tr></table></figure>
<h4 id="如何动态修改容器的内存和cpu限制docker1-10之后才支持的动态调整"><a href="#如何动态修改容器的内存和cpu限制docker1-10之后才支持的动态调整" class="headerlink" title="如何动态修改容器的内存和cpu限制docker1.10之后才支持的动态调整"></a>如何动态修改容器的内存和cpu限制<code>docker1.10之后才支持的动态调整</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sh-4.2# dockerexec test-env cat /sys/fs/cgroup/memory/memory.limit_in_bytes</div><div class="line">9223372036854775807</div><div class="line">sh-4.2# cat /sys/fs/cgroup/memory/memory.limit_in_bytes </div><div class="line">9223372036854775807</div><div class="line">可以看到，默认没有给容器限制内存，它会共享宿主机的所有内存</div><div class="line">动态调整内存为2014M：</div><div class="line">sh-4.2# docker update -m 2014M test-env</div><div class="line">test-env</div><div class="line">sh-4.2# dockerexec test-env cat /sys/fs/cgroup/memory/memory.limit_in_bytes</div><div class="line">2111832064</div></pre></td></tr></table></figure>
<h4 id="docker容器中真实用户的隔离"><a href="#docker容器中真实用户的隔离" class="headerlink" title="docker容器中真实用户的隔离"></a>docker容器中真实用户的隔离</h4><p>注意：默认docker容器内部的用户会继承宿主机的用户id，也就是说容器外部有一个uid为500的用户test，容器内部有一个uid为500的用户admin，容器内部运行的程序如果在宿主机上查看的时候会发现程序的启动用户会是外部宿主机的test用户。<br>这是因为默认情况下容器的 user namespace 并未开启，所以容器内的用户和宿主用户共享 uid 空间。容器内的 uid 为 0 的 root，就被系统视为 uid=0 的宿主 root，因此磁盘读写时，具有宿主 root 同等读写权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开启user namespace：</div><div class="line">启动docker的时候加参数--userns-remap=default</div><div class="line">https://docs.docker.com/engine/reference/commandline/dockerd/#/daemon-user-namespace-options</div></pre></td></tr></table></figure></p>
<h4 id="在docker-container和物理机中双向拷贝文件"><a href="#在docker-container和物理机中双向拷贝文件" class="headerlink" title="在docker container和物理机中双向拷贝文件"></a>在docker container和物理机中双向拷贝文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">容器内部文件拷贝到宿主机：</div><div class="line">sh-4.2# docker cp jupyter-70002111:/home/70002111/教程-研究功能介绍.ipynb .</div><div class="line">sh-4.2# ls</div><div class="line">Dockerfile  教程-研究功能介绍.ipynb</div><div class="line">宿主机文件拷贝到容器：</div><div class="line">sh-4.2# docker cp Dockerfile jupyter-70002111:/home/70002111/</div><div class="line">sh-4.2# docker exec -it jupyter-70002188 ls </div><div class="line">Dockerfile</div></pre></td></tr></table></figure>
<h4 id="向容器内部程序发送signal"><a href="#向容器内部程序发送signal" class="headerlink" title="向容器内部程序发送signal"></a>向容器内部程序发送signal</h4><p>注意：在给容器进程发送SIGTERM信号时只会发给主进程，也就是容器内 PID 为 1 的进程。至于说主进程启动的那些子进程，完全看主进程是否愿意转发SIGTERM 给子进程了。所以那些把 Docker当做虚拟机用的，主进程跑了个bash，然后exec 进去启动程序的，或者来个&amp;让程序跑后台的情况，应用进程必然无法收到SIGTERM。<br><br>还有一种可能是在Dockerfile中的CMD那行用的是 shell 格式写的命令，而不是 exec 格式。在镜像中使用CMD启动的容器会加一个 sh -c 来去执行，因此使用 shell 格式写 CMD 的时候，PID 为 1 的进程是 sh，而它不转发信号，所以主程序收不到。</p>
<p>所以在写CMD哪行命令的时候，最好按照exec格式去写。</p>
<p><code>划重点: 由于在容器内部是没有init进程的，所以容器的整个生命周期会和容器内部PID为1的进程紧密相连，用户在使用过程中经常会发现容器更新版本之后，业务调用方经常会有一些请求异常，这其实也是因为容器内部的1号进程的设置有关，导致容器在停止时可能直接发送SIGKILL信号，导致容器当前正在处理中的业务也会立即断开连接，这样可能会导致一些业务异常</code></p>
<p>总而言之，向容器内部程序发送合适的信号是非常有必要的，这样可以使你的容器很优雅的退出。<code>docker stop操作会让容器在10s后进行优雅的退出</code></p>
<p><a href="https://segmentfault.com/a/1190000008233992" target="_blank" rel="external">如何优雅的关闭容器</a></p>
<h4 id="容器的cache不释放"><a href="#容器的cache不释放" class="headerlink" title="容器的cache不释放"></a>容器的cache不释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo 1 &gt; /proc/sys/vm/drop_caches</div></pre></td></tr></table></figure>
<h4 id="桥接网络连入下层网络并使用IPAM-没有NAT-端口映射"><a href="#桥接网络连入下层网络并使用IPAM-没有NAT-端口映射" class="headerlink" title="桥接网络连入下层网络并使用IPAM (没有NAT/端口映射)"></a>桥接网络连入下层网络并使用IPAM (没有NAT/端口映射)</h4><p><code>注意:docker network是1.12版本加进来的，支持了多种网络插件</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ docker network create \</div><div class="line">	-d bridge \</div><div class="line">	--subnet=192.168.57.0/24 \</div><div class="line">	--ip-range=192.168.57.32/28 \</div><div class="line">	--gateway=192.168.57.11 \</div><div class="line">	--aux-address DefaultGatewayIPv4=192.168.57.1 \</div><div class="line">	-o com.docker.network.bridge.name=brnet \</div><div class="line">	brnet</div><div class="line">$ brctl addif brnet eth2</div><div class="line">$ docker run --net=brnet -it busybox ifconfig</div><div class="line"></div><div class="line">注意其它主机的 --ip-range 和 --gateway 需要做对应调整。</div><div class="line"></div><div class="line">这种拓扑是，容器内 eth0 连接 brnet 接口，该接口直接通过 eth2 访问交换。</div></pre></td></tr></table></figure>
<h4 id="Docker查看某个容器绑定的cpu内核"><a href="#Docker查看某个容器绑定的cpu内核" class="headerlink" title="Docker查看某个容器绑定的cpu内核"></a>Docker查看某个容器绑定的cpu内核</h4><p><code>容器内部第一个进程编号一般为1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker exec -it container-name taskset -c -p 1 </div><div class="line">pid 1&apos;s current affinity list:0-3</div></pre></td></tr></table></figure>
<h4 id="给docker配置hosts"><a href="#给docker配置hosts" class="headerlink" title="给docker配置hosts"></a>给docker配置hosts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker run --add-host biaoge-ops:192.168.0.1 centos cat /etc/hosts</div><div class="line">127.0.0.1	localhost</div><div class="line">::1	localhost ip6-localhost ip6-loopback</div><div class="line">fe00::0	ip6-localnet</div><div class="line">ff00::0	ip6-mcastprefix</div><div class="line">ff02::1	ip6-allnodes</div><div class="line">ff02::2	ip6-allrouters</div><div class="line">192.168.0.1	biaoge-ops</div><div class="line">10.0.0.3	6ff3ea7114b4</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/0231568ab33(" target="_blank" rel="external">原文地址</a><br><a href="https://my.oschina.net/xxbAndy/blog" target="_blank" rel="external">个人博客</a><br>微信公众号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577135-5d2191eacf61c6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechat.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在使用docker过程中，我们经常发现管理维护是一个很复杂过程，因为我们在使用docker commands的过程中，我们只会去使用我们认为简单并且熟悉的命令，然而docker本身其实是提供给我们很多便捷且人性化的工具的，如果掌握这些使用技巧，也许你的维护管理工作将会事半功倍，并且给人看起来会很牛逼的样子。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker API for Python</title>
    <link href="http://yoursite.com/2017/10/30/Docker-API-for-Python/"/>
    <id>http://yoursite.com/2017/10/30/Docker-API-for-Python/</id>
    <published>2017-10-30T14:37:34.000Z</published>
    <updated>2017-10-30T14:40:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>使用Docker API for Python来更好的管理容器！</p>
</blockquote>
<a id="more"></a>
<p><code>客户端初始化的三种方法</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import docker</div><div class="line">docker.api()</div><div class="line">docker.APIClient()</div><div class="line">docker.client()</div><div class="line">docker.DockerClient() 其实就是docker.client()的一个子集</div><div class="line">docker.from_env() 其实也是docker.client()的一个子集</div></pre></td></tr></table></figure></p>
<h3 id="一、初始化客户端"><a href="#一、初始化客户端" class="headerlink" title="一、初始化客户端"></a>一、初始化客户端</h3><h4 id="1-Docker客户端的初始化工作"><a href="#1-Docker客户端的初始化工作" class="headerlink" title="1.Docker客户端的初始化工作"></a>1.Docker客户端的初始化工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; import docker</div><div class="line">&gt;&gt;&gt; client = docker.APIClient(base_url=&apos;unix://var/run/docker.sock’,version=&apos;1.21&apos;,timeout=5)</div><div class="line">&gt;&gt;&gt; client.version()</div><div class="line">&#123;u&apos;ApiVersion&apos;: u&apos;1.21’,</div><div class="line"> u&apos;Arch&apos;: u&apos;amd64&apos;,</div><div class="line"> u&apos;BuildTime&apos;: u&apos;2016-09-27T23:38:15.810178467+00:00&apos;,</div><div class="line"> u&apos;Experimental&apos;: True,</div><div class="line"> u&apos;GitCommit&apos;: u&apos;45bed2c&apos;,</div><div class="line"> u&apos;GoVersion&apos;: u&apos;go1.6.3&apos;,</div><div class="line"> u&apos;KernelVersion&apos;: u&apos;4.4.22-moby&apos;,</div><div class="line"> u&apos;Os&apos;: u&apos;linux&apos;,</div><div class="line"> u&apos;Version&apos;: u&apos;1.12.2-rc1&apos;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Args:</div><div class="line">   base_url (str): 指定链接路径，可以通过socket或者tcp方式链接</div><div class="line">       ``unix:///var/run/docker.sock`` or ``tcp://127.0.0.1:1234``.</div><div class="line">   version (str): 指定API使用的版本(docker=2.0.0默认的api版本是1.24,最低支持1.21,docker1.9+的api是1.21),因此在使用python的docker模块时一定要注意docker的api以及docker模块的api是否兼容。当然如果设置为 ``auto`` 降回去自动检测server的版本</div><div class="line">   timeout (int): 使用API调用的默认超时时间，默认单位为秒</div><div class="line">   tls (bool or :py:class:`~docker.tls.TLSConfig`): Enable TLS. Pass</div><div class="line">       ``True`` to enable it with default options, or pass a</div><div class="line">       :py:class:`~docker.tls.TLSConfig` object to use custom</div><div class="line">       configuration.</div></pre></td></tr></table></figure>
<p><strong>查看docker引擎当前版本:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ sudo docker version</div><div class="line">Client:</div><div class="line"> Version:      1.9.1</div><div class="line"> API version:  1.21</div><div class="line"> Go version:   go1.4.3</div><div class="line"> Git commit:   a34a1d5-dirty</div><div class="line"> Built:        Tue Mar 28 15:39:19 UTC 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      1.9.1</div><div class="line"> API version:  1.21</div><div class="line"> Go version:   go1.4.3</div><div class="line"> Git commit:   a34a1d5-dirty</div><div class="line"> Built:        Tue Mar 28 15:39:19 UTC 2017</div><div class="line"> OS/Arch:      linux/amd64</div></pre></td></tr></table></figure>
<p><strong>The sdk of docker for python–docker==2.0.0:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.丢弃了python2.6的支持</div><div class="line">2.最低支持API版本为1.12(Engine version 1.9.0+)</div><div class="line">3.`docker.Client`被替换成`docker.APIClient`</div><div class="line">4.`docker.from_env`初始化一个docker客户端实例代替了`APIClient `实例 </div><div class="line">5.从`APIClient.start`中移除了HostConfig参数</div><div class="line">6.开始由之前的docker-py模块变为docker</div><div class="line">7.`docker.ssladapter`替换为`docker.transport.ssladapter`</div></pre></td></tr></table></figure>
<p>####2.Docker客户端的具体方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import docker</div><div class="line">C  = docker.DockerClient(base_url=&apos;unix://var/run/docker.sock&apos;,version=&apos;auto&apos;,timeout=10)</div><div class="line"></div><div class="line">##docker相关的方法使用</div><div class="line">使用DockerClient对象，会有以下方法：</div><div class="line">C.api,</div><div class="line">C.containers,</div><div class="line">C.events,</div><div class="line">C.from_env,</div><div class="line">C.images,</div><div class="line">C.info,</div><div class="line">C.login,</div><div class="line">C.networks,</div><div class="line">C.nodes,</div><div class="line">C.ping,</div><div class="line">C.services,</div><div class="line">C.swarm,</div><div class="line">C.version,</div><div class="line">C.volumes,</div><div class="line"></div><div class="line"></div><div class="line">#输出docker的相关信息，相当于docker info</div><div class="line">C.info()</div></pre></td></tr></table></figure>
<h3 id="二、api方法使用示例"><a href="#二、api方法使用示例" class="headerlink" title="二、api方法使用示例"></a>二、api方法使用示例</h3><h4 id="1-login方法定义"><a href="#1-login方法定义" class="headerlink" title="1. login方法定义"></a>1. login方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">C.login()</div><div class="line">login(*args, **kwargs) method of docker.client.DockerClient instance</div><div class="line">    Authenticate with a registry. Similar to the ``docker login`` command.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        username (str): The registry username</div><div class="line">        password (str): The plaintext password</div><div class="line">        email (str): The email for the registry account</div><div class="line">        registry (str): URL to the registry.  E.g.</div><div class="line">            ``https://index.docker.io/v1/``</div><div class="line">        reauth (bool): Whether refresh existing authentication on the</div><div class="line">            Docker server.</div><div class="line">        dockercfg_path (str): Use a custom path for the ``.dockercfg`` file</div><div class="line">    (default ``$HOME/.dockercfg``)</div><div class="line">    </div><div class="line">    Returns:返回的错误日志信息</div><div class="line">        (dict): The response from the login request</div><div class="line"></div><div class="line">          Raises:</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line">            If the server returns an error.</div><div class="line"></div><div class="line">##使用login方法登录</div><div class="line">C.login(&apos;xxbandy123&apos;,&apos;nslalla&apos;)</div></pre></td></tr></table></figure>
<h4 id="2-images-类定义："><a href="#2-images-类定义：" class="headerlink" title="2.images 类定义："></a>2.images 类定义：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">build方法</div><div class="line">get方法：</div><div class="line">get(self, name)</div><div class="line">    Gets an image.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        name (str): The name of the image.</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        (:py:class:`Image`): The image.</div><div class="line">    </div><div class="line">    Raises:</div><div class="line">        :py:class:`docker.errors.ImageNotFound` If the image does not</div><div class="line">        exist.</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line">            If the server returns an error.</div><div class="line">list方法：</div><div class="line">   list(self, name=None, all=False, filters=None)</div><div class="line">    List images on the server.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        name (str): Only show images belonging to the repository ``name``</div><div class="line">        all (bool): Show intermediate image layers. By default, these are</div><div class="line">            filtered out.</div><div class="line">        filters (dict): Filters to be processed on the image list.</div><div class="line">            Available filters:</div><div class="line">            - ``dangling`` (bool)</div><div class="line">            - ``label`` (str): format either ``key`` or ``key=value``</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        (list of :py:class:`Image`): The images.</div><div class="line">    </div><div class="line">    Raises:</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line">            If the server returns an error.</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">查看默认所有的镜像文件，以image-id进行区分</div><div class="line">In [34]: C.images.list()</div><div class="line">Out[34]: </div><div class="line">[&lt;Image: &apos;busybox:latest&apos;&gt;,</div><div class="line"> &lt;Image: &apos;rancher-server:latest&apos;, &apos;rancher/server:latest&apos;&gt;,</div><div class="line"> &lt;Image: &apos;singleuser:latest&apos;&gt;,</div><div class="line"> &lt;Image: &apos;registry:2&apos;&gt;,</div><div class="line"> &lt;Image: &apos;rancher-agent:latest&apos;, &apos;rancher/agent:v1.0.2&apos;&gt;]</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">load方法：相当于docker load</div><div class="line"></div><div class="line">pull方法：下载镜像文件</div><div class="line"> pull(self, name, **kwargs)</div><div class="line">    Pull an image of the given name and return it. Similar to the</div><div class="line">    ``docker pull`` command.</div><div class="line">    </div><div class="line">    If you want to get the raw pull output, use the</div><div class="line">    :py:meth:`~docker.api.image.ImageApiMixin.pull` method in the</div><div class="line">    low-level API.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        repository (str): The repository to pull</div><div class="line">        tag (str): The tag to pull</div><div class="line">        insecure_registry (bool): Use an insecure registry</div><div class="line">        auth_config (dict): Override the credentials that</div><div class="line">            :py:meth:`~docker.client.DockerClient.login` has set for</div><div class="line">            this request. ``auth_config`` should contain the ``username``</div><div class="line">            and ``password`` keys to be valid.</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        (:py:class:`Image`): The image that has been pulled.</div><div class="line"></div><div class="line">需要注意的是：使用pull的时候，会弱匹配所有的tag标签</div><div class="line"></div><div class="line">push方法：上传镜像文件</div><div class="line"></div><div class="line">push(self, repository, tag=None, **kwargs)</div><div class="line">    Push an image or a repository to the registry. Similar to the ``docker</div><div class="line">    push`` command.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        repository (str): The repository to push to</div><div class="line">        tag (str): An optional tag to push</div><div class="line">        stream (bool): Stream the output as a blocking generator</div><div class="line">        insecure_registry (bool): Use ``http://`` to connect to the</div><div class="line">            registry</div><div class="line">        auth_config (dict): Override the credentials that</div><div class="line">            :py:meth:`~docker.api.daemon.DaemonApiMixin.login` has set for</div><div class="line">            this request. ``auth_config`` should contain the ``username``</div><div class="line">            and ``password`` keys to be valid.</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        (generator or str): The output from the server.</div><div class="line">    </div><div class="line">    Raises:</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line"></div><div class="line">remove方法：docker rmi </div><div class="line"> remove(self, *args, **kwargs)</div><div class="line">    Remove an image. Similar to the ``docker rmi`` command.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        image (str): The image to remove</div><div class="line">        force (bool): Force removal of the image</div><div class="line">        noprune (bool): Do not delete untagged parents</div><div class="line"></div><div class="line">search方法：</div><div class="line">search(self, *args, **kwargs)</div><div class="line">    Search for images on Docker Hub. Similar to the ``docker search``</div><div class="line">    command.</div><div class="line">    </div><div class="line">    Args:</div><div class="line">        term (str): A term to search for.</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        (list of dicts): The response of the search.</div></pre></td></tr></table></figure>
<h4 id="3-docker管理容器相关"><a href="#3-docker管理容器相关" class="headerlink" title="3.docker管理容器相关"></a>3.docker管理容器相关</h4><p>C.containers类，下面有相关的方法：</p>
<ul>
<li>client</li>
<li>create</li>
<li>get</li>
<li>list</li>
<li>model</li>
<li>run …</li>
</ul>
<p>列出当前存活的容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C.containers.list()</div></pre></td></tr></table></figure></p>
<p>列出指定容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C.containers.get(&apos;&apos;)</div></pre></td></tr></table></figure></p>
<p>创建容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">C.containers.create</div><div class="line">create(image, command=None, **kwargs) method of docker.models.containers.ContainerCollection instance</div><div class="line">    Create a container without starting it. Similar to ``docker create``.</div><div class="line">    </div><div class="line">    Takes the same arguments as :py:meth:`run`, except for ``stdout``,</div><div class="line">    ``stderr``, and ``remove``.</div><div class="line">    </div><div class="line">    Returns:</div><div class="line">        A :py:class:`Container` object.</div><div class="line">    </div><div class="line">    Raises:</div><div class="line">        :py:class:`docker.errors.ImageNotFound`</div><div class="line">            If the specified image does not exist.</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line">            If the server returns an error.</div><div class="line"></div><div class="line"></div><div class="line">run一个容器：类似于命令行的docker run方法</div><div class="line">run(image, command=None, stdout=True, stderr=False, remove=False, **kwargs) method of docker.models.containers.ContainerCollection instance</div><div class="line">    Run a container. By default, it will wait for the container to finish</div><div class="line">    and return its logs, similar to ``docker run``.</div><div class="line">    </div><div class="line">    如果&apos;detach&apos;参数设置为&apos;True&apos;,他将立即返回一个Container对象，类似于&apos;docker run -d&apos;    </div><div class="line">    实例:</div><div class="line">        运行一个容器并获取输出。</div><div class="line">    </div><div class="line">        &gt;&gt;&gt; import docker</div><div class="line">        &gt;&gt;&gt; client = docker.from_env()</div><div class="line">        &gt;&gt;&gt; client.containers.run(&apos;alpine&apos;, &apos;echo hello world&apos;)</div><div class="line">        b&apos;hello world\n&apos;</div><div class="line">    </div><div class="line">        后台运行一个容器:</div><div class="line">        &gt;&gt;&gt; container = client.containers.run(&apos;bfirsh/reticulate-splines&apos;,</div><div class="line">                                              detach=True)</div><div class="line">        获取该容器的日志信息</div><div class="line">        &gt;&gt;&gt; container.logs()</div><div class="line">        &apos;Reticulating spline 1...\nReticulating spline 2...\n&apos;</div><div class="line"></div><div class="line">   参数介绍:</div><div class="line">        image (str): run一个容器所需要的镜像(str类型)</div><div class="line">        command (str or list): 容器启动默认运行的命令(字符串或者列表类型).</div><div class="line"></div><div class="line">        blkio_weight_device: 设置设备Block IO 权重：``[&#123;&quot;Path&quot;: &quot;device_path&quot;, &quot;Weight&quot;: weight&#125;]``.</div><div class="line">        blkio_weight: 设置block IO 的权重 范围10-1000.</div><div class="line">        cap_add (list of str): 增加内核特性 比如：``[&quot;SYS_ADMIN&quot;, &quot;MKNOD&quot;]``.</div><div class="line">        cap_drop (list of str): 删除内核特性</div><div class="line">        cpu_group (int): 每颗cpu的长度</div><div class="line">        cpu_period (int): 容器在每一个cpu的时间周期内可以得到多少的的cpu时间(ms)</div><div class="line">        cpu_shares (int): 共享cpu权重CPU 相对权重</div><div class="line">        cpuset_cpus (str): 绑定cpu的执行 (``0-3``,``0,1``).</div><div class="line"></div><div class="line">        detach (bool): 后台运行一个容器，布尔类型值.相当于docker run -d选项</div><div class="line"></div><div class="line">        device_read_bps: 从一个设备上限制读速率(bytes/s) `[&#123;&quot;Path&quot;: &quot;device_path&quot;, &quot;Rate&quot;: rate&#125;]`</div><div class="line">        device_read_iops: 从一个设备中限制读取速率(IO/s)</div><div class="line">        device_write_bps: 从一个设备上限制写速率(bytes/s)</div><div class="line">        device_write_iops: 从一个设备中限制读取速率(IO/s)</div><div class="line">        devices (list): 映射主机的设备到容器中``&lt;path_on_host&gt;:&lt;path_in_container&gt;:&lt;cgroup_permissions&gt;``.</div><div class="line">        dns (list): 配置当前的dns-server</div><div class="line">        dns_opt (list): 添加额外的dns参数选项到容器内部，比如resolv.conf文件</div><div class="line">        dns_search (list): 设置dns搜索域</div><div class="line">        domainname (str or list): 设置当前dns搜索域名</div><div class="line"></div><div class="line">        entrypoint (str or list): 为容器设置入口,覆盖镜像中的entrypoint</div><div class="line"></div><div class="line">        environment (dict or list): 内部环境变量[&quot;SOMEVARIABLE=xxx&quot;]``</div><div class="line">        extra_hosts (dict): 在容器内部添加额外的主机名解析(本地hosts文件)</div><div class="line">        group_add (list): 设置容器内部进程运行时额外的组名（gid）</div><div class="line"></div><div class="line">        hostname (str): 容器设置额外的主机名.相当于docker run -h/--hostname 选项</div><div class="line"></div><div class="line">        ipc_mode (str): 为容器设置ipc模式</div><div class="line">        isolation (str): 隔离技术的使用Default: `None`.</div><div class="line">        labels (dict or list): 一个k/v类型的标签存储``&#123;&quot;label1&quot;: &quot;value1&quot;, &quot;label2&quot;: &quot;value2&quot;&#125;``)或一个列表类型的k/v存储``[&quot;label1&quot;, &quot;label2&quot;]``</div><div class="line">        links (dict or list of tuples): 为容器映射一个别名``(name, alias)`` </div><div class="line">        log_config (dict): 容器的日志配置。</div><div class="line">            keys:</div><div class="line">            - ``type`` The logging driver name.</div><div class="line">            - ``config`` A dictionary of configuration for the logging</div><div class="line">              driver.</div><div class="line">        mac_address (str): 绑定mac地址.</div><div class="line"></div><div class="line">        mem_limit (float or str): 内存限制，允许浮点型数据或单位区分的字符串(``100000b``, ``1000k``, ``128m``, ``1g``). 如果一个字符串没有指定单位，默认会使用字节(bytes)</div><div class="line">        mem_limit (str or int): 容器可以使用的最大内存数量(e.g. ``1G``).</div><div class="line"></div><div class="line">        mem_swappiness (int): 调整容器内存的swappiness行为状态，允许的数值为0-100 </div><div class="line">        memswap_limit (str or int): 最大内存限制，容器可用的内存为(memory+swap)</div><div class="line">        networks (list): 设置连接到该容器网络的名称</div><div class="line">        name (str): 为容器设置名字</div><div class="line">        network_disabled (bool): 禁用容器网络</div><div class="line">        network_mode (str): 网络模式 相当于docker run --net=&apos;none&apos;</div><div class="line">    </div><div class="line">            - ``bridge`` 默认使用桥接模式</div><div class="line">            - ``none`` 无网络模式</div><div class="line">            - ``container:&lt;name|id&gt;`` 重用另外一个容器的网络</div><div class="line">            - ``host`` 使用本机的网络栈</div><div class="line"></div><div class="line"></div><div class="line">        oom_kill_disable (bool): 是否启用OOM</div><div class="line">        oom_score_adj (int): 一个整数，以调整OOM的整体性能.</div><div class="line">        pid_mode (str): pid模式，如果设置为&apos;host&apos;,在容器内部将会使用宿主机的host pid</div><div class="line">        pids_limit (int): 调整容器的pid的限制。&apos;-1&apos;表示不限制</div><div class="line"></div><div class="line">        ports (dict): 为容器内部绑定端口 相当于docker run -p </div><div class="line">    		实例：</div><div class="line">              ``&#123;&apos;2222/tcp&apos;: 3333&#125;`` 暴露容器内部的2222端口到本机的3333端</div><div class="line">              ``&#123;&apos;2222/tcp&apos;: None&#125;`` 将容器内部的2222随机映射到本机</div><div class="line">              ``&#123;&apos;1111/tcp&apos;: (&apos;127.0.0.1&apos;, 1111)&#125;``.</div><div class="line">              ``&#123;&apos;1111/tcp&apos;: [1234, 4567]&#125;`` 绑定多个端口</div><div class="line"></div><div class="line"></div><div class="line">		privileged (bool): 给容器额外的特权</div><div class="line"></div><div class="line">        publish_all_ports (bool): 开放所有的端口到本机上 相当于docker run -P </div><div class="line"></div><div class="line">        read_only (bool): 以只读方式挂载容器的根文件系统</div><div class="line">        remove (bool): 当容器退出的时候删除，默认是&apos;False&apos;</div><div class="line">        restart_policy (dict): 当容器退出时重启容器</div><div class="line">            配置参数如下：</div><div class="line">            - ``Name`` One of ``on-failure``, or ``always``.</div><div class="line">            - ``MaximumRetryCount`` 容器失败多少次后进行重启</div><div class="line">            实例:</div><div class="line">            ``&#123;&quot;Name&quot;: &quot;on-failure&quot;, &quot;MaximumRetryCount&quot;: 5&#125;``</div><div class="line">    </div><div class="line">        security_opt (list): 设置安全标签，类似于selinux</div><div class="line">        shm_size (str or int): /dev/shm 的大小(e.g. ``1G``).</div><div class="line"></div><div class="line">        stdin_open (bool): 保持 ``STDIN`` 打开即使没有attach到容器内部相当于docker run -i</div><div class="line"></div><div class="line">        stdout (bool): 当detach=False的时候，从&apos;STDOUT&apos;返回日志。默认为True</div><div class="line">        stdout (bool): 当detach=False的时候，从&apos;STDERR&apos;返回日志，默认为False</div><div class="line">        stop_signal (str): 设置用于停止容器的信号。(e.g. ``SIGINT``).</div><div class="line">        sysctls (dict): 容器内部设置内核参数</div><div class="line">        tmpfs (dict): 挂载临时文件系统 </div><div class="line">                        .. code-block:: python</div><div class="line">    </div><div class="line">                &#123;</div><div class="line">                    &apos;/mnt/vol2&apos;: &apos;&apos;,</div><div class="line">                    &apos;/mnt/vol1&apos;: &apos;size=3G,uid=1000&apos;</div><div class="line">                &#125;</div><div class="line">    </div><div class="line">        tty (bool): 分配一个tty 相当于docker run -t</div><div class="line"></div><div class="line">        ulimits (list): 在容器内部设置ulimits值，一个字典类型的列表</div><div class="line">        user (str or int): 设置容器启动的用户名以及id</div><div class="line"></div><div class="line">        userns_mode (str): 为容器设置用户的命名空间模式，当用户的namespace的remapping参数被启用的时候，支持参数有&apos;host&apos;</div><div class="line">            values are: ``host``</div><div class="line">        volume_driver (str): 数据卷挂载驱动名</div><div class="line">        volumes (dict or list): 一个字典配置，将外部数据卷挂载到容器内部，key是主机或者数据卷的名字，value是带有key的字典：</div><div class="line">        		实例：</div><div class="line">                &#123;&apos;/home/user1/&apos;: &#123;&apos;bind&apos;: &apos;/mnt/vol2&apos;, &apos;mode&apos;: &apos;rw&apos;&#125;,</div><div class="line">                 &apos;/var/www&apos;: &#123;&apos;bind&apos;: &apos;/mnt/vol1&apos;, &apos;mode&apos;: &apos;ro&apos;&#125;&#125;</div><div class="line">    </div><div class="line">        volumes_from (list): 获取容器名或者id标识。</div><div class="line">        working_dir (str): 容器默认的工作目录</div><div class="line">    </div><div class="line">    返回参数:</div><div class="line">        容器的日志，包含 ``STDOUT``, ``STDERR``</div><div class="line">        If ``detach`` is ``True``, a :py:class:`Container` object is</div><div class="line">        returned instead.</div><div class="line">    </div><div class="line">    异常信息:</div><div class="line">    	如果容器以非0状态退出，或者`detach`参数为`False`</div><div class="line">        :py:class:`docker.errors.ContainerError`</div><div class="line">        如果指定的镜像不存在</div><div class="line">        :py:class:`docker.errors.ImageNotFound`</div><div class="line">        如果是服务返回一个错误</div><div class="line">        :py:class:`docker.errors.APIError`</div><div class="line">            If the server returns an error.</div></pre></td></tr></table></figure>
<p>示例：<br>一个完整的创建容器的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Command line:</div><div class="line">$ docker run -itd -P --cpuset_cpus=&apos;0,1&apos; --cpu_shares=2 --cpu_period=10000 --hostname=xxbandy --mem_limit=512m --net=none --oom_kill_disable=True -P -u admin busybox /bin/sh</div><div class="line"></div><div class="line">Python API:</div><div class="line">c1 = C.containers.run(&apos;busybox&apos;,command=&apos;/bin/sh&apos;,name=&apos;xxb-test&apos;,detach=True,tty=True,stdin_open=True,cpuset_cpus=&apos;0,1&apos;,cpu_shares=2,cpu_period=10000,hostname=&apos;xxbandy&apos;,mem_limit=&apos;512m&apos;,network_mode=&apos;none&apos;,oom_kill_disable=True,publish_all_ports=True,user=&apos;root&apos;)</div><div class="line"></div><div class="line">查看容器相关信息：</div><div class="line">容器id，64位的字符</div><div class="line">In [20]: c1.id</div><div class="line">Out[20]: &apos;499db0824206d61d09db2f36c70aa84bdb1a4b6d508b001a618d2010a23fea7e&apos;</div><div class="line"></div><div class="line"></div><div class="line">c1.logs </div><div class="line">c1.name      获取容器名信息</div><div class="line">c1.reload</div><div class="line">c1.remove    删除容器信息，相当于docker rm 参数：c1.remove(v=True,link=True,force=True)</div><div class="line">c2.rename	 重命名容器名，相当于docker renmame oldname newname</div><div class="line">c1.resize	 设置tty session信息</div><div class="line">c1.restart   重启容器信息</div><div class="line">c1.start     启动容器信息</div><div class="line">c1.stats     容器状态</div><div class="line"></div><div class="line">c1.update    动态调整容器内部信息（blkio_weight，cpu_period，cpu_quota，cpu_shares，cpuset_cpus，cpuset_mems，mem_limit，mem_reservation）</div><div class="line">    Args:</div><div class="line">        blkio_weight (int): 块IO权重比例（10-100）</div><div class="line">        cpu_period (int): 限制cpu公平调度周期</div><div class="line">        cpu_quota (int): 限制cpu公平调度配额</div><div class="line">        cpu_shares (int): 设置cpu共享权重</div><div class="line">        cpuset_cpus (str): 指定cpu执行(0-3, 0,1)</div><div class="line">        cpuset_mems (str): 指定cpu内存的执行(0-3, 0,1)</div><div class="line">        mem_limit (int or str): 内存限制</div><div class="line">        mem_reservation (int or str): 内存软限制</div><div class="line">        memswap_limit (int or str): swap限制总的可使用内存限制(memory + swap)，-1表示关闭swap</div><div class="line">        kernel_memory (int or str): 内核内存限制</div><div class="line">        restart_policy (dict): 重启策略</div></pre></td></tr></table></figure>
<p><code>注意:</code>update方法在docker1.10之后才增加了改功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">查看容器相关信息：</div><div class="line">容器id，64位的字符</div><div class="line">In [20]: c1.id</div><div class="line">Out[20]: &apos;499db0824206d61d09db2f36c70aa84bdb1a4b6d508b001a618d2010a23fea7e&apos;</div><div class="line"></div><div class="line">可以在/sys/fs/cgroup/memory/docker目录下面查看到每个容器的相关cgroup配置信息。</div><div class="line">查看内存信息：</div><div class="line"># grep hierarchical memory.stat     分别显示容器的内存限制和swap限制</div><div class="line">hierarchical_memory_limit 536870912</div><div class="line">hierarchical_memsw_limit 1073741824</div><div class="line"></div><div class="line">#cat memory.limit_in_bytes</div><div class="line">536870912</div><div class="line"></div><div class="line">可以在/sys/fs/cgroup/cpuset/docker目录下面查看到容器cpu的相关配置</div><div class="line"># cat cpuset.cpus       显示当前绑定的cpu信息</div><div class="line">0-1</div><div class="line">使用docker update动态调整内存信息:</div><div class="line">docker update -m 1024M xuxuebiao-test</div><div class="line"></div><div class="line"># cat memory.limit_in_bytes </div><div class="line">1073741824</div><div class="line"># grep hierarchical_memory_limit memory.stat </div><div class="line">hierarchical_memory_limit 1073741824</div></pre></td></tr></table></figure>
<p>个人博客：<a href="https://my.oschina.net/xxbAndy/blog" target="_blank" rel="external">https://my.oschina.net/xxbAndy/blog</a><br>微信公众号：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2577135-5d2191eacf61c6dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wechat.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用Docker API for Python来更好的管理容器！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>GPU环境下玩转Docker(三)</title>
    <link href="http://yoursite.com/2017/10/30/GPU%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%8E%A9%E8%BD%ACDocker-%E4%B8%89/"/>
    <id>http://yoursite.com/2017/10/30/GPU环境下玩转Docker-三/</id>
    <published>2017-10-30T14:08:39.000Z</published>
    <updated>2017-10-30T14:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>前言: 在前面两个章节中已经介绍了如何构建GPU的基础环境以及使用Docker方式来优雅的运行GPU应用，单纯的使用Docker这种方式是无法满足大规模的应用调度和管理的，对于集群调度以及容器化管理方面，我们也采用了业界比较知名的容器编排调度管理工具Kubernetes，本篇文章简单介绍GPU业务容器在Kubernetes上的运行。</p>
</blockquote>
<a id="more"></a>
<p><a href="https://xxbandy.github.io/2017/10/26/GPU%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%8E%A9%E8%BD%ACDocker-%E4%B8%80/" target="_blank" rel="external">GPU环境下玩转Docker(一)</a></p>
<p><a href="https://xxbandy.github.io/2017/10/26/GPU%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%8E%A9%E8%BD%ACDocker-%E4%BA%8C/" target="_blank" rel="external">GPU环境下玩转Docker(二)</a></p>
<h3 id="使用Kubernetes调度GPU容器"><a href="#使用Kubernetes调度GPU容器" class="headerlink" title="使用Kubernetes调度GPU容器"></a>使用Kubernetes调度GPU容器</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h4><p>k8s当前已经支持GPU的资源调度了，详情可查看中文文档：<a href="https://k8smeetup.github.io/docs/tasks/manage-gpus/scheduling-gpus/" target="_blank" rel="external">k8s调度GPU</a>。<br>这里介绍一个简单的实例。</p>
<p><code>注意：官方网站中也提到，当前k8s调度GPU也还是处于实验性阶段，在测试K8S调度GPU之前需要做以下相关工作。</code></p>
<ul>
<li>Kubernetes 节点必须预先安装好 NVIDIA 驱动，否则，Kubelet 将检测不到可用的GPU信息；如果节点的 Capacity 属性中没有出现 NIVIDA GPU 的数量，有可能是驱动没有安装或者安装失败，请尝试重新安装</li>
<li><p>在整个 Kubernetes 系统中，feature-gates 里面特定的 alpha 特性参数 Accelerators 必须设置为 true：–feature-gates=”Accelerators=true”</p>
</li>
<li><p>Kuberntes 节点必须使用 docker 引擎作为容器的运行引擎</p>
</li>
</ul>
<p>以上工作完成后，节点会自动发现主机上的NVIDIA GPU机器，并将其作为可调度资源暴露。</p>
<p><code>注意1：为了防止错误调度，需要给GPU机器去做额外的标签</code><br><code>注意2：kubelet程序在启动时必须加载--allow-privileged=true参数，以对所有的GPU容器设置特权模式来识别宿主机资源</code></p>
<p><strong>kubelet启动参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"># cat  /usr/lib/systemd/system/kubelet.service | grep -v ^#</div><div class="line">[Unit]</div><div class="line">Description=Kubernetes Kubelet Server</div><div class="line">Documentation=https://github.com/GoogleCloudPlatform/kubernetes</div><div class="line">After=docker.service</div><div class="line">Requires=docker.service</div><div class="line"></div><div class="line">[Service]</div><div class="line">WorkingDirectory=/export/lib/kubelet</div><div class="line">EnvironmentFile=-/export/kubernetes/config</div><div class="line">EnvironmentFile=-/export/kubernetes/kubelet</div><div class="line">ExecStart=/usr/bin/kubelet \</div><div class="line">            $KUBE_LOGTOSTDERR \</div><div class="line">            $KUBE_LOG_LEVEL \</div><div class="line">            $KUBELET_API_SERVER \</div><div class="line">            $KUBELET_ADDRESS \</div><div class="line">            $KUBELET_PORT \</div><div class="line">            $KUBELET_HOSTNAME \</div><div class="line">            $KUBE_ALLOW_PRIV \</div><div class="line">            $KUBELET_POD_INFRA_CONTAINER \</div><div class="line">            $KUBELET_ARGS \</div><div class="line">Restart=on-failure</div><div class="line"></div><div class="line"></div><div class="line"># cat  /export/kubernetes/kubelet | grep -v ^#</div><div class="line">KUBELET_ADDRESS=&quot;--address=10.0.0.1&quot;</div><div class="line">KUBELET_HOSTNAME=&quot;--hostname-override=10.0.0.1&quot;</div><div class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=idockerhub.xxb.com/k8s/pause&quot;</div><div class="line">KUBELET_ARGS=&quot;--cgroup-driver=cgroupfs \</div><div class="line">                --cluster-dns=10.254.0.2 \</div><div class="line">                --experimental-bootstrap-kubeconfig=/export/kubernetes/bootstrap.kubeconfig \</div><div class="line">                --kubeconfig=/export/kubernetes/kubelet.kubeconfig \</div><div class="line">                --require-kubeconfig \</div><div class="line">                --cert-dir=/export/kubernetes/ssl \</div><div class="line">                --cluster-domain=cluster.local. \</div><div class="line">                --hairpin-mode promiscuous-bridge \</div><div class="line">                --serialize-image-pulls=false \</div><div class="line">                --feature-gates=&apos;Accelerators=true&apos;&quot;</div><div class="line"></div><div class="line"># cat  /export/kubernetes/config | grep -v ^#</div><div class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</div><div class="line"></div><div class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</div><div class="line"></div><div class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=true&quot;</div><div class="line"></div><div class="line">KUBE_MASTER=&quot;--master=http://10.0.0.2:8080&quot;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#/usr/bin/kubelet --logtostderr=true --v=0 --address=10.0.0.1 --hostname-override=10.0.0.1 --allow-privileged=true --pod-infra-container-image=idockerhub.xxb.com/k8s/pause --cgroup-driver=cgroupfs --cluster-dns=10.254.0.2 --experimental-bootstrap-kubeconfig=/export/kubernetes/bootstrap.kubeconfig --kubeconfig=/export/kubernetes/kubelet.kubeconfig --require-kubeconfig --cert-dir=/export/kubernetes/ssl --cluster-domain=cluster.local. --hairpin-mode promiscuous-bridge --serialize-image-pulls=false --feature-gates=Accelerators=true Restart=on-failure</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># /usr/local/bin/kubectl -s http://10.0.0.2:8080 label nodes 10.0.0.1 type=gpu</div><div class="line"></div><div class="line"># /usr/local/bin/kubectl -s http://10.0.0.2:8080 get nodes  --show-labels</div><div class="line">NAME             STATUS    AGE       VERSION   LABELS</div><div class="line">10.0.0.2     Ready     2d        v1.6.2    beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/hostname=10.0.0.2</div><div class="line">10.0.0.1   Ready     4h        v1.6.2    beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/hostname=10.0.0.1,type=gpu</div><div class="line"></div><div class="line"></div><div class="line"># /usr/local/bin/kubectl -s http://10.0.0.2:8080 get node -l type=gpu</div><div class="line">NAME             STATUS    AGE       VERSION</div><div class="line">10.0.0.1   Ready     4h        v1.6.2</div></pre></td></tr></table></figure>
<h4 id="2-测试用例"><a href="#2-测试用例" class="headerlink" title="2. 测试用例"></a>2. 测试用例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: test-gpu</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        name: test-gpu</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: test-gpu</div><div class="line">        image: idockerhub.xxb.com/k8s/tensorflow/tensorflow:latest-gpu</div><div class="line">        ports:</div><div class="line">        - containerPort: 8888</div><div class="line">        resources:</div><div class="line">          limits:</div><div class="line">            alpha.kubernetes.io/nvidia-gpu: 2</div><div class="line">        volumeMounts:</div><div class="line">            - mountPath: /usr/local/nvidia</div><div class="line">              name: nvidia-driver</div><div class="line">            - mountPath: /dev/nvidia0</div><div class="line">              name: nvidia0</div><div class="line">            - mountPath: /dev/nvidia-uvm</div><div class="line">              name: nvidia-uvm</div><div class="line">            - mountPath: /dev/nvidia-uvm-tools</div><div class="line">              name: nvidia-uvm-tools</div><div class="line">            - mountPath: /dev/nvidiactl</div><div class="line">              name: nvidiactl</div><div class="line">      volumes:</div><div class="line">        - name: nvidia-driver</div><div class="line">          hostPath:</div><div class="line">            path: /var/lib/nvidia-docker/volumes/nvidia_driver/375.39</div><div class="line">        - name: nvidia0</div><div class="line">          hostPath:</div><div class="line">            path: /dev/nvidia0</div><div class="line">        - name: nvidia-uvm</div><div class="line">          hostPath:</div><div class="line">            path: /dev/nvidia-uvm</div><div class="line">        - name: nvidia-uvm-tools</div><div class="line">          hostPath:</div><div class="line">            path: /dev/nvidia-uvm-tools</div><div class="line">        - name: nvidiactl</div><div class="line">          hostPath:</div><div class="line">            path: /dev/nvidiactl</div></pre></td></tr></table></figure>
<p><code>注意1：k8s调度gpudocker容器需要和业务方进行强关联，所以对于cuda,cudnn,nvidia-docker的版本要求是非常高的。</code><br><code>注意2：k8s调度的gpu其实是独享的，也就是上面分配了2个gpu设备，那么该宿主机上将最多只能创建2个卡的gpu容器，否则会因为资源不够而调度失败。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># ll /var/lib/nvidia-docker/volumes/nvidia_driver/</div><div class="line">total 0</div><div class="line">drwxr-xr-x 5 nvidia-docker nvidia-docker 38 Oct 18 21:38 375.39</div><div class="line"></div><div class="line"></div><div class="line"># docker ps</div><div class="line">CONTAINER ID        IMAGE                                                                                                                    COMMAND                  CREATED             STATUS              PORTS                                              NAMES</div><div class="line">f3a3f8dd30ca        idockerhub.xxb.com/jdjr/tensorflow-gpu@sha256:7844f390a9d5ff369c7756a52ca65dae095087c736935e9310e12c7caa7c73dd            &quot;/run_jupyter.sh --al&quot;   2 days ago          Up 2 days                                                              k8s_test-gpu_test-gpu-1430106381-9n8hb_default_97177dcf-b7da-11e7-b982-ecf4bbc19ea8_0</div><div class="line">7650dce5a686        idockerhub.xxb.com/k8s/pause                                                                                              &quot;/pod&quot;                   2 days ago          Up 2 days                                                              k8s_POD_test-gpu-1430106381-9n8hb_default_97177dcf-b7da-11e7-b982-ecf4bbc19ea8_0</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 尝试创建一个4卡的gpu设备的容器</div><div class="line"># docker exec -it 0cce1f2a59dd ls -la /dev/nvidia*</div><div class="line">crw-rw-rw- 1 root root 244,   0 Jul 19 05:14 /dev/nvidia-uvm</div><div class="line">crw-rw-rw- 1 root root 244,   1 Jul 19 05:14 /dev/nvidia-uvm-tools</div><div class="line">crw-rw-rw- 1 root root 195,   0 Jun 20 02:54 /dev/nvidia0</div><div class="line">crw-rw-rw- 1 root root 195,   1 Oct 23 10:06 /dev/nvidia1</div><div class="line">crw-rw-rw- 1 root root 195,   2 Oct 23 10:06 /dev/nvidia2</div><div class="line">crw-rw-rw- 1 root root 195,   3 Oct 23 10:06 /dev/nvidia3</div><div class="line">crw-rw-rw- 1 root root 195, 255 Jun 20 02:54 /dev/nvidiactl</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">尝试运算服务后的结果：</div><div class="line">2017-10-23 10:14:25.172617: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1045] Creating TensorFlow device (/gpu:0) -&gt; (device: 0, name: Tesla M40 24GB, pci bus id: 0000:06:00.0)</div></pre></td></tr></table></figure>
<p>通过上述测试用例，就可以跑通官方tensorflow gpu镜像。</p>
<p><code>NOTES:</code></p>
<blockquote>
<p>GPUs 只能通过limits选项指定<br>GPUs 是严格隔离的，不同容器之间不能共享<br>每个容器可以请求一个或者多个GPUS<br>GPUs 只能正整数级请求<br>使用K8S调度GPU容器必须开启privileged模式(识别宿主机设备)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言: 在前面两个章节中已经介绍了如何构建GPU的基础环境以及使用Docker方式来优雅的运行GPU应用，单纯的使用Docker这种方式是无法满足大规模的应用调度和管理的，对于集群调度以及容器化管理方面，我们也采用了业界比较知名的容器编排调度管理工具Kubernetes，本篇文章简单介绍GPU业务容器在Kubernetes上的运行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
      <category term="NVIDIA" scheme="http://yoursite.com/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>Manager-your-GPUs.md</title>
    <link href="http://yoursite.com/2017/10/30/Manager-your-GPUs/"/>
    <id>http://yoursite.com/2017/10/30/Manager-your-GPUs/</id>
    <published>2017-10-30T14:03:27.000Z</published>
    <updated>2018-01-19T02:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用nvidia-smi管理你的GPU卡"><a href="#使用nvidia-smi管理你的GPU卡" class="headerlink" title="使用nvidia-smi管理你的GPU卡"></a>使用nvidia-smi管理你的GPU卡</h2><p><code>nvidia-smi</code>命令是NVIDIA系统管理接口，之前提到使用<code>nvidia-docker</code>实际上底层也是调用的该接口。该接口可以查看到当前主机上的相关GPU设备，任务以及当前状态等信息，熟练使用该接口能够更好的管理好GPU系统资源。</p>
<a id="more"></a>
<h3 id="开启持久模式"><a href="#开启持久模式" class="headerlink" title="开启持久模式"></a>开启持久模式</h3><p>在Linux上，你需要将GPUs设置为持久模式<code>persistence mode</code>来保证你的<code>NVIDIA</code>驱动即使没有应用正在运行也是出于加载状态的。这个在你有一些短生命周期的job类型应用运行时是非常有用的。持久模式比较耗电，但是它会防止每次启动GPU应用程序时发生的相当长的延迟。当然如果你使用设定了时钟频率或功率限制的GPUs的话(当驱动不加载的话，这些设置会丢失)，持久模式将是非常有必要的。通过如下命令设置持久模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nvidia-smi -pm 1</div></pre></td></tr></table></figure></p>
<p>在Windows上，改接口不支持设置持久模式，但是可以设置为<code>TCC</code>模式。</p>
<h3 id="查看GPU状态"><a href="#查看GPU状态" class="headerlink" title="查看GPU状态"></a>查看GPU状态</h3><p>1.GPU设备概要信息<br>由以下输出可以看到驱动版本为：<code>375.39</code>,以及GPU基本信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">sh-4.2# nvidia-smi</div><div class="line">Wed Oct 18 11:58:03 2017</div><div class="line">+-----------------------------------------------------------------------------+</div><div class="line">| NVIDIA-SMI 375.39                 Driver Version: 375.39                    |</div><div class="line">|-------------------------------+----------------------+----------------------+</div><div class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</div><div class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</div><div class="line">|===============================+======================+======================|</div><div class="line">|   0  Tesla M40 24GB      On   | 0000:04:00.0     Off |                    0 |</div><div class="line">| N/A   23C    P8    17W / 250W |      0MiB / 22939MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   1  Tesla M40           On   | 0000:05:00.0     Off |                    0 |</div><div class="line">| N/A   26C    P8    17W / 250W |      0MiB / 11443MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   2  Tesla M40 24GB      On   | 0000:06:00.0     Off |                    0 |</div><div class="line">| N/A   22C    P8    17W / 250W |      0MiB / 22939MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line">|   3  Tesla M40           On   | 0000:07:00.0     Off |                    0 |</div><div class="line">| N/A   23C    P8    16W / 250W |      0MiB / 11443MiB |      0%      Default |</div><div class="line">+-------------------------------+----------------------+----------------------+</div><div class="line"></div><div class="line">+-----------------------------------------------------------------------------+</div><div class="line">| Processes:                                                       GPU Memory |</div><div class="line">|  GPU       PID  Type  Process name                               Usage      |</div><div class="line">|=============================================================================|</div><div class="line">|  No running processes found                                                 |</div><div class="line">+-----------------------------------------------------------------------------+</div><div class="line"></div><div class="line"># Temp 标识GPU设备的温度</div><div class="line"># Memory-Usage 表示内存使用率</div><div class="line"># GPU-Util 表示GPU使用率</div></pre></td></tr></table></figure></p>
<p>2.查看当前系统可用的GPU设备列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -L</div><div class="line">GPU 0: Tesla M40 24GB (UUID: GPU-eb4e4871-504d-feb7-ba59-xxxxxxxxxx)</div><div class="line">GPU 1: Tesla M40 (UUID: GPU-6c2cb0c9-acba-1dab-6525-xxxxxxxxxx)</div><div class="line">GPU 2: Tesla M40 24GB (UUID: GPU-85551fe5-68ea-15b3-76c1-6fe1sas2w    1)</div><div class="line">GPU 3: Tesla M40 (UUID: GPU-8fe0a30b-7faa-0537-e3a5-53ba5c8a61wesd)</div></pre></td></tr></table></figure>
<p>3.查看GPU以及单元信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -q</div></pre></td></tr></table></figure></p>
<p>4.查看每一个GPU指定详细信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># nvidia-smi --query-gpu=index,name,uuid,serial --format=csv</div><div class="line">index, name, uuid, serial</div><div class="line">0, Tesla M40 24GB, GPU-eb4e4871-504d-feb7-ba59-xxxxxxxx, xxxxxxxxxx</div><div class="line">1, Tesla M40, GPU-6c2cb0c9-acba-1dab-6525-xxxxxxxx, xxxxxxxxxx</div><div class="line">2, Tesla M40 24GB, GPU-85551fe5-68ea-15b3-76c1-xxxxxxxx, xxxxxxxxxx</div><div class="line">3, Tesla M40, GPU-8fe0a30b-7faa-0537-e3a5-xxxxxxxx, xxxxxxxxxx</div></pre></td></tr></table></figure></p>
<p>5.指定GPU查看相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># nvidia-smi --query-gpu=index,name,uuid,serial --format=csv --id=0</div><div class="line">index, name, uuid, serial</div><div class="line">0, Tesla M40 24GB, GPU-eb4e4871-504d-feb7-ba59-d15a66d6faa7, 0322816142509</div></pre></td></tr></table></figure></p>
<h3 id="监控和管理GPU-Boost"><a href="#监控和管理GPU-Boost" class="headerlink" title="监控和管理GPU Boost"></a>监控和管理GPU Boost</h3><p>管理员和用户可以使用这种方式来观察GPUs的状态。<br>以下显示了每个GPU的可用时钟频率(Tesla M40)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -q -d SUPPORTED_CLOCKS</div><div class="line">GPU 0000:07:00.0</div><div class="line">    Supported Clocks</div><div class="line">        Memory                      : 3004 MHz</div><div class="line">            Graphics                : 1114 MHz</div><div class="line">            Graphics                : 1088 MHz</div><div class="line">            Graphics                : 1063 MHz</div><div class="line">            Graphics                : 1038 MHz</div><div class="line">            Graphics                : 1013 MHz</div><div class="line">            Graphics                : 987 MHz</div><div class="line">            Graphics                : 962 MHz</div><div class="line">            Graphics                : 949 MHz</div><div class="line">            Graphics                : 924 MHz</div><div class="line">            Graphics                : 899 MHz</div><div class="line">            Graphics                : 873 MHz</div><div class="line">            Graphics                : 848 MHz</div><div class="line">            Graphics                : 823 MHz</div><div class="line">            Graphics                : 797 MHz</div><div class="line">            Graphics                : 772 MHz</div><div class="line">            Graphics                : 747 MHz</div><div class="line">            Graphics                : 721 MHz</div><div class="line">            Graphics                : 696 MHz</div><div class="line">            Graphics                : 671 MHz</div><div class="line">            Graphics                : 645 MHz</div><div class="line">            Graphics                : 620 MHz</div><div class="line">            Graphics                : 595 MHz</div><div class="line">            Graphics                : 557 MHz</div><div class="line">            Graphics                : 532 MHz</div><div class="line">        Memory                      : 405 MHz</div><div class="line">            Graphics                : 324 MHz</div></pre></td></tr></table></figure>
<p>以上显示中只有两个内存时钟(memory clock)被支持：3004 MHz和405 MHz.运行在前者的内存，有24个支持GPU时钟频率。后者只有一个GPU频率，且是空闲状态的。在Tesla K80上，GPU Boost会自动管理这些频率，来让他们运行的尽可能快。而在其他一些模块中，比如Tesla K40，必须由管理员来指定GPU时钟频率。</p>
<p>查看当前GPU的时钟频率，默认的时钟加速和最小的时钟频率<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -q -d CLOCK</div><div class="line"></div><div class="line">GPU 0000:07:00.0</div><div class="line">    Clocks</div><div class="line">        Graphics                    : 949 MHz</div><div class="line">        SM                          : 949 MHz</div><div class="line">        Memory                      : 3004 MHz</div><div class="line">        Video                       : 873 MHz</div><div class="line">    Applications Clocks</div><div class="line">        Graphics                    : 947 MHz</div><div class="line">        Memory                      : 3004 MHz</div><div class="line">    Default Applications Clocks</div><div class="line">        Graphics                    : 947 MHz</div><div class="line">        Memory                      : 3004 MHz</div><div class="line">    Max Clocks</div><div class="line">        Graphics                    : 1114 MHz</div><div class="line">        SM                          : 1114 MHz</div><div class="line">        Memory                      : 3004 MHz</div><div class="line">        Video                       : 1024 MHz</div><div class="line">    SM Clock Samples</div><div class="line">        Duration                    : 10989718.85 sec</div><div class="line">        Number of Samples           : 46</div><div class="line">        Max                         : 1063 MHz</div><div class="line">        Min                         : 324 MHz</div><div class="line">        Avg                         : 948 MHz</div><div class="line">    Memory Clock Samples</div><div class="line">        Duration                    : 10989718.85 sec</div><div class="line">        Number of Samples           : 46</div><div class="line">        Max                         : 3004 MHz</div><div class="line">        Min                         : 405 MHz</div><div class="line">        Avg                         : 3003 MHz</div><div class="line">    Clock Policy</div><div class="line">        Auto Boost                  : On</div><div class="line">        Auto Boost Default          : On</div></pre></td></tr></table></figure></p>
<p>理想状态中，你想让所有的时钟都一直运行在比较高的速度，但是对于所有的应用来说是不可能的。可以使用PERFORMANCE参数来查看每个GPU卡当前的状态以及时钟慢下来的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -q -d PERFORMANCE/performance</div><div class="line">GPU 0000:07:00.0</div><div class="line">    Performance State               : P0</div><div class="line">    Clocks Throttle Reasons</div><div class="line">        Idle                        : Not Active</div><div class="line">        Applications Clocks Setting : Active</div><div class="line">        SW Power Cap                : Not Active</div><div class="line">        HW Slowdown                 : Not Active</div><div class="line">        Sync Boost                  : Not Active</div><div class="line">        Unknown                     : Not Active</div></pre></td></tr></table></figure>
<p>如果任何一个GPU时钟都以比较慢速度运行的话，那么上面的<code>Clocks Throttle Reasons</code>中的一个或多个将会被标记为active状态。最需要关注的是<code>HW Slowdown</code>和<code>Unknown</code>是否是active状态，如果那样的话很可能是电源或者冷却系统的问题。其余的需要关注设备卡是否是空闲的或者是由管理员手动设置为<code>slower</code>模式。</p>
<p>使用<code>nvidia-smi</code>还可以去监控其他相关指标，-d参数支持<code>MEMORY UTILIZATION ECC TEMPERATURE POWER CLOCK COMPUTE PIDS PERFORMANCE SUPPORTED_CLOCKS PAGE_RETIREMENT ACCOUNTING</code></p>
<p>查看每块GPU卡的内存使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -q -d memory</div><div class="line"></div><div class="line">GPU 0000:06:00.0</div><div class="line">    FB Memory Usage</div><div class="line">        Total                       : 22939 MiB</div><div class="line">        Used                        : 21800 MiB</div><div class="line">        Free                        : 1139 MiB</div><div class="line">    BAR1 Memory Usage</div><div class="line">        Total                       : 32768 MiB</div><div class="line">        Used                        : 2 MiB</div><div class="line">        Free                        : 32766 MiB</div><div class="line"></div><div class="line">GPU 0000:07:00.0</div><div class="line">    FB Memory Usage</div><div class="line">        Total                       : 11443 MiB</div><div class="line">        Used                        : 10876 MiB</div><div class="line">        Free                        : 567 MiB</div><div class="line">    BAR1 Memory Usage</div><div class="line">        Total                       : 16384 MiB</div><div class="line">        Used                        : 2 MiB</div><div class="line">        Free                        : 16382 MiB</div></pre></td></tr></table></figure>
<p>指定GPU卡查看相关指标：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nvidia-smi -i 0 -q -d MEMORY,UTILIZATION,POWER,CLOCK,COMPUTE</div></pre></td></tr></table></figure></p>
<h3 id="查看系统的拓扑结构"><a href="#查看系统的拓扑结构" class="headerlink" title="查看系统的拓扑结构"></a>查看系统的拓扑结构</h3><p>要适当的利用更先进的NVIDIA GPU优势(例如GPU Direct)，因此系统的拓扑结构的正确配置是非常重要的。拓扑结构涉及到<code>PCI-Express</code>(GPUs, InfiniBand HCAs, storage controllers, etc)设备如何连接到其他设备，以及如何连接到系统CPU的。如果配置不正确，可能某些特定的功能性能会比较低甚至不能正常工作。为了解决如上问题，<code>nvidia-smi</code>最近的版本包含了一个可用查看系统拓扑的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 显示GPU拓扑(-m参数可以看到GPU交流矩阵以及CPU亲和性绑定)</div><div class="line">$  nvidia-smi topo -m</div><div class="line">	GPU0	GPU1	GPU2	GPU3	CPU Affinity</div><div class="line">GPU0	 X 	PIX	PIX	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU1	PIX	 X 	PIX	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU2	PIX	PIX	 X 	PIX	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line">GPU3	PIX	PIX	PIX	 X 	0-0,2-2,4-4,6-6,8-8,10-10,12-12,14-14,16-16,18-18,20-20,22-22</div><div class="line"></div><div class="line">Legend:</div><div class="line"></div><div class="line">  X   = Self</div><div class="line">  SOC  = Connection traversing PCIe as well as the SMP link between CPU sockets(e.g. QPI)</div><div class="line">  PHB  = Connection traversing PCIe as well as a PCIe Host Bridge (typically the CPU)</div><div class="line">  PXB  = Connection traversing multiple PCIe switches (without traversing the PCIe Host Bridge)</div><div class="line">  PIX  = Connection traversing a single PCIe switch</div><div class="line">  NV#  = Connection traversing a bonded set of # NVLinks</div></pre></td></tr></table></figure>
<p>以上配置显示我们有四块GOU卡，并且都链接在服务器的第一颗CPU上(物理机2颗6核cpu并开启超线程)。该工具建议推荐我们将job运行在偶数标记的cpu上。并且以上四块GPU卡都是互相通过PCIe switch直连的。</p>
<p>一个可用的GPU矩阵表示如下：</p>
<ul>
<li>X = 表示GPU本身</li>
<li>SOC = 表示贯穿PCIe总线和CPU sockets之间的SMP链接。</li>
<li>PHB = 贯穿PCIe总线和PCIe Host Bridge</li>
<li>PXB = 贯穿多个PCIe switch(不通过PCIe Host Bridge)</li>
<li>PIX = 链接单个PCIe switch</li>
<li>NV# = 贯穿一组NVLinks设备</li>
</ul>
<p><code>划重点啦：其实由上面的GPU拓扑可以看出来，我们系统上的4块设备是两两互相直连的架构！因为4块卡是通过一个PCIe switch来互相通信的。大体结构如图：</code><br><img src="http://oyep1jupk.bkt.clouddn.com/docker/nvidia-docker/gpu-topo.png" alt=""></p>
<p><strong><code>补充：查看GPU卡之间的邻居和链接关系</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># nvidia-smi topo 命令有个参数-n可以用来指定gpu卡以及互联结构来查看和它互联结构</div><div class="line">#                   0 = a single PCIe switch on a dual GPU board</div><div class="line">#                   1 = a single PCIe switch</div><div class="line">#                   2 = multiple PCIe switches</div><div class="line">#                   3 = a PCIe host bridge</div><div class="line">#                   4 = a socket-level link</div><div class="line"></div><div class="line"># 查看每个GPU卡所在的socket上链接的其他GPU卡设备</div><div class="line">for uuid in `nvidia-smi --query-gpu=uuid --format=csv | grep GPU  | xargs`;do nvidia-smi topo -i $uuid -n 4;done</div><div class="line"># 查看每个GPU卡所在的PCIe host bridge 上链接的其他GPU卡设备</div><div class="line">for uuid in `nvidia-smi --query-gpu=uuid --format=csv | grep GPU  | xargs`;do nvidia-smi topo -i $uuid -n 3;done</div><div class="line"># 查看每个GPU卡所在的PCIe switch 上链接的其他GPU卡设备</div><div class="line">for uuid in `nvidia-smi --query-gpu=uuid --format=csv | grep GPU  | xargs`;do nvidia-smi topo -i $uuid -n 1;done</div></pre></td></tr></table></figure></p>
<p><a href="https://www.microway.com/hpc-tech-tips/nvidia-smi_control-your-gpus/" target="_blank" rel="external">nvidia-smi命令使用帮助</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用nvidia-smi管理你的GPU卡&quot;&gt;&lt;a href=&quot;#使用nvidia-smi管理你的GPU卡&quot; class=&quot;headerlink&quot; title=&quot;使用nvidia-smi管理你的GPU卡&quot;&gt;&lt;/a&gt;使用nvidia-smi管理你的GPU卡&lt;/h2&gt;&lt;p&gt;&lt;code&gt;nvidia-smi&lt;/code&gt;命令是NVIDIA系统管理接口，之前提到使用&lt;code&gt;nvidia-docker&lt;/code&gt;实际上底层也是调用的该接口。该接口可以查看到当前主机上的相关GPU设备，任务以及当前状态等信息，熟练使用该接口能够更好的管理好GPU系统资源。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="GPU" scheme="http://yoursite.com/tags/GPU/"/>
    
      <category term="NVIDIA" scheme="http://yoursite.com/tags/NVIDIA/"/>
    
  </entry>
  
</feed>
